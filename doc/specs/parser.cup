package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
    
    SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
    SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
    ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
    FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}  

parser code {:
    SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
    
    public void syntax_error(Symbol symbol)
    { 
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxError ("Error sintactico", token);     
    }
        
    public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
    {   
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxFatalError ("Error fatal", token);
    }
:}

// Declaración de terminales (Ejemplo)

// Palabras reservadas
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;

// OPERADORES
terminal Token PLUS;
terminal Token MAYOR;
terminal Token IGUAL;
terminal Token ASIGNACION;
terminal Token ACCESO;

// DELIMITADORES
terminal Token ABRE_PARENTESIS;
terminal Token CIERRA_PARENTESIS;
terminal Token DELIMITADOR_RANGO;
terminal Token SEPARADOR_COMA;
terminal Token PUNTO_COMA;
terminal Token DOS_PUNTOS;

// OTROS
terminal Token NUMERO;
terminal Token IDENTIFICADOR;
terminal Token CADENA;

// Declaración de no terminales
// no modificar los propuestos

non terminal            program;
non terminal Axiom      axiom;

non terminal    vacio;
non terminal    cabecera;
non terminal    declaraciones;
non terminal    declaracion_constantes;
non terminal    declaracion_registros;
non terminal    declaracion_variables;
non terminal    declaracion_subprogramas;
non terminal    lista_nombres;
non terminal    constante;
non terminal    valor;

non terminal    registro;
non terminal    ListaObjetos lista_campos;
non terminal    tipo;

non terminal    variable;
non terminal    cuerpo;
non terminal    lista_sentencias;
non terminal    sentencia;
non terminal    sentencia_entrada_salida;
non terminal    sentencia_asignacion;
non terminal    sentencia_if;
non terminal    sentencia_for;
non terminal    referencia;
non terminal    acceso_registro;
non terminal    expresion;
non terminal    parametro;
non terminal    llamada_subprograma;
non terminal    lista_parametros;
non terminal    subprograma;
non terminal    funcion;
non terminal    procedimiento;
non terminal    parametros_subprograma;
non terminal    tipo_primitivo;
non terminal    cuerpo_funcion;
non terminal    lista_sentencias_funcion;
non terminal    sentencia_funcion;
non terminal    sentencia_return;

// Declaración de relaciones de precedencia, SEPARADOS POR COMAS

precedence left OR;
precedence left IGUAL;
precedence left MAYOR;
precedence left PLUS;
precedence left ACCESO, ABRE_PARENTESIS, CIERRA_PARENTESIS;

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
        // No modificar esta estructura, aunque se pueden añadir más acciones semánticas
        
        List intermediateCode = ax.getIntermediateCode ();
        finalCodeFactory.create (intermediateCode);
                
        syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= cabecera declaraciones cuerpo
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

vacio ::= ;

cabecera ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS CIERRA_PARENTESIS IS
    {:
        //Crear el ámbito global del programa asociado al nombre del procedimiento.
        String name = id.getLexema();
        scopeManager.openScope(name);
        ScopeIF scope = scopeManager.getCurrentScope();
        semanticErrorManager.semanticDebug("Abierto ambito " + name);
        
        //******************* Ahora insertar tipos basicos en la tabla
        TypeTableIF tablaTipos = scope.getTypeTable();
        TypeSimple tipoBooleano = new TypeSimple(scope);
        tipoBooleano.setName("BOOLEAN");
        tablaTipos.addType(tipoBooleano);
        TypeSimple tipoEntero = new TypeSimple(scope);
        tipoEntero.setName("INTEGER");
        tablaTipos.addType(tipoEntero);
    :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de cabecera."); :};

tipo ::= IDENTIFICADOR:id  {: RESULT=id.getLexema();:}
        | INTEGER:t {: RESULT="INTEGER"; :} 
        | BOOLEAN:t {: RESULT="BOOLEAN"; :};

tipo_primitivo ::= INTEGER:t {: RESULT="INTEGER"; :} 
        | BOOLEAN:t {: RESULT="BOOLEAN"; :};
        
valor ::= NUMERO {: RESULT="INTEGER"; :}
        | TRUE {: RESULT="BOOLEAN"; :}
        | FALSE {: RESULT="BOOLEAN"; :};             

declaraciones ::= declaracion_constantes;

declaracion_constantes ::= constante declaracion_constantes 
        | declaracion_registros;

/*******************************************************************************
CAMBIAR LA CONSTANTE EN TRES PRODUCCIONES SEGUN EL TIPO DE VALOR
1 Divido valor en valor_numerico y valor_booleano
2 Divido la produccion constante en constante:: ...valor_numeroco | ...valor_booleano
*******************************************************************************/
constante ::= lista_nombres:listaNombres DOS_PUNTOS CONSTANT ASIGNACION valor:v PUNTO_COMA
    {:
        ScopeIF scope = scopeManager.getCurrentScope();
        String nombreConstante = (String)((ListaObjetos)listaNombres).get(0);
        semanticErrorManager.semanticInfo("Declaracion de constante " + nombreConstante);
        // comprueba si la constante ha sido declarada y se encuentra en la tabla de simbolos
        if (scope.getSymbolTable().containsSymbol(nombreConstante)) {
            semanticErrorManager.semanticFatalError("Error: la constante "+nombreConstante+" ya ha sido declarada");
        } else {
            // Creo la constante en el ambito
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            String tipo = (String)v;
            SymbolConstant simboloCte = new SymbolConstant(scope,nombreConstante,scopeManager.searchType(tipo));
            // La guardo en la tabla de simbolos
            tablaSimbolos.addSymbol(nombreConstante, simboloCte);
            semanticErrorManager.semanticInfo("Constante " + nombreConstante + " " + tipo + " guardada en la tabla de simbolos");
        }
    :};
    
lista_nombres ::= IDENTIFICADOR:id SEPARADOR_COMA lista_nombres:listaNombres
    {:
        semanticErrorManager.semanticInfo("Se encuentra el nombre " + id.getLexema()); 
        semanticErrorManager.semanticInfo("Se encuentra el listado " + listaNombres.toString());
        ListaObjetos listaResultado = new ListaObjetos((ListaObjetos)listaNombres);
        listaResultado.add(id.getLexema());
        RESULT = listaResultado;
    :}
    | IDENTIFICADOR:id
    {:
        ListaObjetos listaNombres = new ListaObjetos();
        listaNombres.add(id.getLexema());
        RESULT = listaNombres;
    :};

declaracion_registros ::= registro declaracion_registros 
        | declaracion_variables;
        
registro ::= TYPE IDENTIFICADOR:idRegistro IS RECORD lista_campos:listaCamposRegistro END RECORD PUNTO_COMA
    {:
        syntaxErrorManager.syntaxInfo("Declaracion de registro " + idRegistro.getLexema() + ". Linea " + idRegistro.getLine());
        // Comprueba en la tabla de tipos si el tipo ya está declarado
        ScopeIF scope = scopeManager.getCurrentScope();
        
        TypeTableIF typeTable = scope.getTypeTable();
        
        if (typeTable.containsType(idRegistro.getLexema())) {
            semanticErrorManager.semanticFatalError("Error: el tipo "+idRegistro.getLexema()+" en la linea: "+idRegistro.getLine()+" ya ha sido declarado");
        } else {
            TypeRecord tipoRegistro = new TypeRecord(scope, idRegistro.getLexema());
            typeTable.addType(tipoRegistro);
            syntaxErrorManager.syntaxInfo("Tipo registro " + idRegistro.getLexema() + ". Añadido en la tabla de tipos");
            // Compruebo los campos
        for (int i = 0; i<listaCamposRegistro.size();i++) {
            CampoRegistro c = (CampoRegistro) listaCamposRegistro.get(i);
            SymbolVariable var = (SymbolVariable) c.getSymbol();
            if (!tipoRegistro.containsCampo(c.getNombre())) {
                semanticErrorManager.semanticInfo("Se inserta el campo " + c.getNombre() + "linea " + c.getLinea() + "... ");
                tipoRegistro.addCampo(c.getNombre(), var); 
                semanticErrorManager.semanticInfo("...OK!");                                        
            } else {
                semanticErrorManager.semanticFatalError ("El campo: " + c.getNombre() +" en " + c.getLinea() + " ya ha sido definido.");
            }
        } 
        }
        
        
    :};

/**
    CAMBIO: Elimino el no terminal campo y lo sustituyo por su produccion
**/
lista_campos ::= IDENTIFICADOR:idCampo DOS_PUNTOS tipo:tipoCampo PUNTO_COMA lista_campos:listaCampos
    {:
    // Añadir ID + tipo a lista de campos del registro registro
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF tablaTipos = scope.getTypeTable();
    SymbolIF simbolo = new SymbolVariable(scope,
                                            idCampo.getLexema(),
                                            scopeManager.searchType(tipoCampo.toString()));
    CampoRegistro campo = new CampoRegistro(idCampo.getLexema(), idCampo.getLine(), 
                                            idCampo.getColumn(), simbolo);
    semanticErrorManager.semanticInfo("Identificado el campo " + campo.getNombre() + ". ");
    if (listaCampos == null) {
        listaCampos = new ListaObjetos();
    }
    listaCampos.add(campo);
    
    RESULT = listaCampos;
    :} 
    | vacio;
   

declaracion_variables ::= variable declaracion_variables 
        | declaracion_subprogramas {:syntaxErrorManager.syntaxDebug("Declaracion subprogramas");:};
/**
    CAMBIO: sustituyo lista_nombres por su produccion
**/
variable ::= lista_nombres:objListaNombres DOS_PUNTOS tipo:objTipo PUNTO_COMA
    {:
        String tipoVariable = (String)objTipo;
        ListaObjetos listaNombres = (ListaObjetos)objListaNombres; 
        semanticErrorManager.semanticDebug("Declaracion variables de tipo " + tipoVariable);
        
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF tablaTipos = scope.getTypeTable();
        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
        
        // Si el tipo no existe, error
        if (!tablaTipos.containsType(tipoVariable)) {
            semanticErrorManager.semanticFatalError("ERROR: El tipo " 
                                + tipoVariable + 
                                " no ha sido definido en el programa");
        } else {
            semanticErrorManager.semanticDebug("Encontrado el tipo, valida que no haya nombres duplicados");
	        // Para cada nombre creo una variable
	        for (Object objeto:listaNombres.getVariables()) {
	           String nombreVar = (String)objeto;
	            semanticErrorManager.semanticInfo("Declaracion de variable " + nombreVar);
	            if (tablaSimbolos.containsSymbol(nombreVar)) {
	               semanticErrorManager.semanticFatalError("ERROR: variable duplicada " + nombreVar);
	            } else {
	               semanticErrorManager.semanticDebug("Variable valida, crea el simbolo");
	               SymbolVariable sV = new SymbolVariable(scope, nombreVar, tablaTipos.getType(tipoVariable));
	               tablaSimbolos.addSymbol(nombreVar, sV);
	            }
	        }
        }
        semanticErrorManager.semanticDebug("End declaracion variable");
    :};


declaracion_subprogramas ::= subprograma declaracion_subprogramas 
        | vacio;
        
subprograma ::= funcion {:syntaxErrorManager.syntaxDebug("Declaracion funcion");:} 
    | procedimiento {:syntaxErrorManager.syntaxDebug("Declaracion procedimiento");:}; 

funcion ::= FUNCTION IDENTIFICADOR ABRE_PARENTESIS parametros_subprograma CIERRA_PARENTESIS RETURN tipo_primitivo IS declaraciones cuerpo_funcion;

parametros_subprograma ::= lista_nombres DOS_PUNTOS tipo PUNTO_COMA parametros_subprograma
        | lista_nombres DOS_PUNTOS tipo
        | vacio;
        
procedimiento ::= PROCEDURE IDENTIFICADOR ABRE_PARENTESIS parametros_subprograma CIERRA_PARENTESIS  IS declaraciones cuerpo;

cuerpo_funcion::= BEGIN lista_sentencias_funcion END IDENTIFICADOR PUNTO_COMA;

lista_sentencias_funcion ::=  sentencia_funcion PUNTO_COMA lista_sentencias_funcion |  vacio;

sentencia_funcion ::= sentencia | sentencia_return;

sentencia_return ::= RETURN expresion;



cuerpo ::=  BEGIN lista_sentencias END IDENTIFICADOR PUNTO_COMA
    {:
        semanticErrorManager.semanticDebug("Cierro ambito ");
        scopeManager.closeScope();
    :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en cuerpo de procedimiento."); :};
        
lista_sentencias ::=  sentencia PUNTO_COMA lista_sentencias 
        |  vacio;

sentencia ::= sentencia_entrada_salida 
        | sentencia_if
        | sentencia_for
        | sentencia_asignacion
        | llamada_subprograma;

sentencia_if ::= IF expresion THEN lista_sentencias END IF
        | IF expresion THEN lista_sentencias ELSE lista_sentencias END IF
        | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia if"); :};


sentencia_for ::=  FOR expresion IN expresion DELIMITADOR_RANGO expresion LOOP lista_sentencias END LOOP;      
        
sentencia_asignacion ::= referencia ASIGNACION expresion;

referencia ::= IDENTIFICADOR 
        | acceso_registro;

acceso_registro ::= IDENTIFICADOR ACCESO acceso_registro
        | IDENTIFICADOR ACCESO IDENTIFICADOR;
        
/*******************************************************************************
    CAMBIO: TRUE,FALSE pasan a valor_booleano
    NUMERO pasa a valor_numerico
*******************************************************************************/
expresion ::= expresion PLUS expresion
        | expresion MAYOR expresion
        | expresion IGUAL expresion
        | expresion OR expresion      
        | ABRE_PARENTESIS expresion CIERRA_PARENTESIS
        | llamada_subprograma
        | referencia
        | CADENA
        | valor;

sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS parametro CIERRA_PARENTESIS;

parametro ::= CADENA 
        | NUMERO 
        | referencia;

llamada_subprograma ::= IDENTIFICADOR ABRE_PARENTESIS lista_parametros CIERRA_PARENTESIS;

lista_parametros ::= expresion SEPARADOR_COMA lista_parametros
        | expresion
        | vacio;