package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
    
    SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
//    SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
//    ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
    FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}  

parser code {:
    SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
    
    public void syntax_error(Symbol symbol)
    { 
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxError ("Error sintactico", token);     
    }
        
    public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
    {   
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxFatalError ("Error fatal", token);
    }
:}

// Declaración de terminales (Ejemplo)

// Palabras reservadas
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;

// OPERADORES
terminal Token PLUS;
terminal Token MAYOR;
terminal Token IGUAL;
terminal Token ASIGNACION;
terminal Token ACCESO;

// DELIMITADORES
terminal Token ABRE_PARENTESIS;
terminal Token CIERRA_PARENTESIS;
terminal Token DELIMITADOR_RANGO;
terminal Token SEPARADOR_COMA;
terminal Token PUNTO_COMA;
terminal Token DOS_PUNTOS;

// OTROS
terminal Token NUMERO;
terminal Token IDENTIFICADOR;
terminal Token CADENA;

// Declaración de no terminales
// no modificar los propuestos

non terminal            program;
non terminal Axiom      axiom;

non terminal    vacio;
non terminal    cabecera;
non terminal    declaraciones;
non terminal    declaracion_constantes;
non terminal    declaracion_registros;
non terminal    declaracion_variables;
non terminal    declaracion_subprogramas;
non terminal    inicio_declaracion;
non terminal    lista_nombres;
non terminal    constante;
non terminal    valor;

non terminal    registro;
non terminal    lista_campos;
non terminal    campo;
non terminal    tipo;

non terminal    variable;
non terminal    cuerpo;
non terminal    lista_sentencias;
non terminal    sentencia;
non terminal    sentencia_entrada_salida;
non terminal    sentencia_asignacion;
non terminal    sentencia_if;
non terminal    sentencia_for;
non terminal    referencia;
non terminal    acceso_registro;
non terminal    expresion;
non terminal    parametro;
non terminal    llamada_subprograma;
non terminal    lista_parametros;
non terminal    subprograma;
non terminal    funcion;
non terminal    procedimiento;
non terminal    parametros_subprograma;
non terminal    tipo_primitivo;
non terminal    cuerpo_funcion;
non terminal    lista_sentencias_funcion;
non terminal    sentencia_funcion;
non terminal    sentencia_return;

// Declaración de relaciones de precedencia, SEPARADOS POR COMAS

precedence left OR;
precedence left IGUAL;
precedence left MAYOR;
precedence left PLUS;
precedence left ACCESO, ABRE_PARENTESIS, CIERRA_PARENTESIS;

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
        // No modificar esta estructura, aunque se pueden añadir más acciones semánticas
        
        //List intermediateCode = ax.getIntermediateCode ();
        //finalCodeFactory.create (intermediateCode);

        
        syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= cabecera declaraciones cuerpo
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

vacio ::= ;

cabecera ::= PROCEDURE IDENTIFICADOR ABRE_PARENTESIS CIERRA_PARENTESIS IS
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de cabecera."); :};

declaraciones ::= declaracion_constantes;

declaracion_constantes ::= constante declaracion_constantes 
        | declaracion_registros;

declaracion_registros ::= registro declaracion_registros 
        | declaracion_variables;

declaracion_variables ::= variable declaracion_variables 
        | declaracion_subprogramas;

declaracion_subprogramas ::= subprograma declaracion_subprogramas 
        | vacio;
        
subprograma ::= funcion | procedimiento; 

funcion ::= FUNCTION IDENTIFICADOR ABRE_PARENTESIS parametros_subprograma CIERRA_PARENTESIS RETURN tipo_primitivo IS declaraciones cuerpo_funcion;

parametros_subprograma ::= lista_nombres DOS_PUNTOS tipo PUNTO_COMA parametros_subprograma
        | lista_nombres DOS_PUNTOS tipo
        | vacio;
        
procedimiento ::= PROCEDURE IDENTIFICADOR ABRE_PARENTESIS parametros_subprograma CIERRA_PARENTESIS  IS declaraciones cuerpo;

cuerpo_funcion::= BEGIN lista_sentencias_funcion END IDENTIFICADOR PUNTO_COMA;

lista_sentencias_funcion ::=  sentencia_funcion PUNTO_COMA lista_sentencias_funcion |  vacio;

sentencia_funcion ::= sentencia | sentencia_return;

sentencia_return ::= RETURN expresion;

constante ::= inicio_declaracion CONSTANT ASIGNACION valor PUNTO_COMA;

valor ::= TRUE | FALSE | NUMERO;

registro ::= TYPE IDENTIFICADOR IS RECORD lista_campos END RECORD PUNTO_COMA;

lista_campos ::= campo lista_campos | campo;

campo ::= IDENTIFICADOR DOS_PUNTOS tipo PUNTO_COMA;

tipo ::= IDENTIFICADOR | INTEGER | BOOLEAN;

tipo_primitivo ::= INTEGER | BOOLEAN;

variable ::= inicio_declaracion tipo PUNTO_COMA;

inicio_declaracion ::= lista_nombres DOS_PUNTOS;

lista_nombres ::= IDENTIFICADOR SEPARADOR_COMA lista_nombres | IDENTIFICADOR;

cuerpo ::=  BEGIN lista_sentencias END IDENTIFICADOR PUNTO_COMA
        | error {: syntaxErrorManager.syntaxDebug ("Error en cuerpo de procedimiento."); :};
        
lista_sentencias ::=  sentencia PUNTO_COMA lista_sentencias 
        |  vacio;

sentencia ::= sentencia_entrada_salida 
        | sentencia_if
        | sentencia_for
        | sentencia_asignacion
        | llamada_subprograma;

sentencia_if ::= IF expresion THEN lista_sentencias END IF
        | IF expresion THEN lista_sentencias ELSE lista_sentencias END IF
        | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia if"); :};


sentencia_for ::=  FOR expresion IN expresion DELIMITADOR_RANGO expresion LOOP lista_sentencias END LOOP;      
        
sentencia_asignacion ::= referencia ASIGNACION expresion;

referencia ::= IDENTIFICADOR 
        | acceso_registro;

acceso_registro ::= IDENTIFICADOR ACCESO acceso_registro
        | IDENTIFICADOR ACCESO IDENTIFICADOR;
        
expresion ::= expresion PLUS expresion
        | expresion MAYOR expresion
        | expresion IGUAL expresion
        | expresion OR expresion      
        | ABRE_PARENTESIS expresion CIERRA_PARENTESIS
        | llamada_subprograma
        | referencia
        | CADENA
        | TRUE
        | FALSE
        | NUMERO;

sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS parametro CIERRA_PARENTESIS;

parametro ::= CADENA 
        | NUMERO 
        | referencia;

llamada_subprograma ::= IDENTIFICADOR ABRE_PARENTESIS lista_parametros CIERRA_PARENTESIS;

lista_parametros ::= expresion SEPARADOR_COMA lista_parametros
        | expresion
        | vacio;