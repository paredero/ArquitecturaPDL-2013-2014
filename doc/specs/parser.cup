package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
    
    SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
    SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
    ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
    FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}  

parser code {:
    SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
    
    public void syntax_error(Symbol symbol)
    { 
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxError ("Error sintactico", token);     
    }
        
    public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
    {   
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxFatalError ("Error fatal", token);
    }
:}

// Declaración de terminales (Ejemplo)

// Palabras reservadas
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;

// OPERADORES
terminal Token PLUS;
terminal Token MAYOR;
terminal Token IGUAL;
terminal Token ASIGNACION;
terminal Token ACCESO;

// DELIMITADORES
terminal Token ABRE_PARENTESIS;
terminal Token CIERRA_PARENTESIS;
terminal Token DELIMITADOR_RANGO;
terminal Token SEPARADOR_COMA;
terminal Token PUNTO_COMA;
terminal Token DOS_PUNTOS;

// OTROS
terminal Token NUMERO;
terminal Token IDENTIFICADOR;
terminal Token CADENA;

// Declaración de no terminales
// no modificar los propuestos

non terminal            program;
non terminal Axiom      axiom;

non terminal    vacio;
non terminal    cabecera;
non terminal    declaraciones;
non terminal    declaracion_constantes;
non terminal    declaracion_registros;
non terminal    declaracion_variables;
non terminal    declaracion_subprogramas;
non terminal    lista_nombres;
non terminal    constante;
non terminal    Valor   valor;

non terminal    registro;
non terminal    ListaObjetos lista_campos;
non terminal    tipo;

non terminal    variable;
non terminal    cuerpo;
non terminal    lista_sentencias;
non terminal    sentencia;
non terminal    sentencia_entrada_salida;
non terminal    sentencia_asignacion;
non terminal    sentencia_if;
non terminal    sentencia_for;
non terminal    Referencia referencia;
non terminal    Referencia acceso_registro;
non terminal    Expresion expresion;
non terminal    Parametro parametro;
non terminal    Expresion llamada_subprograma;
non terminal    ListaParametrosEjecucion lista_parametros;
non terminal    subprograma;
non terminal    funcion;
non terminal    procedimiento;
non terminal    parametros_subprograma;
non terminal    tipo_primitivo;
non terminal    cuerpo_funcion;
non terminal    lista_sentencias_funcion;
non terminal    sentencia_funcion;
non terminal    sentencia_return;

// Declaración de relaciones de precedencia, SEPARADOS POR COMAS

precedence left OR;
precedence left IGUAL;
precedence left MAYOR;
precedence left PLUS;
precedence left ACCESO, ABRE_PARENTESIS, CIERRA_PARENTESIS;

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
        // No modificar esta estructura, aunque se pueden añadir más acciones semánticas
        
        List intermediateCode = ax.getIntermediateCode ();
        finalCodeFactory.create (intermediateCode);
                
        syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= cabecera declaraciones cuerpo
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

vacio ::= ;

cabecera ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS CIERRA_PARENTESIS IS
    {:
        //Crear el ámbito global del programa asociado al nombre del procedimiento.
        String name = id.getLexema();
        scopeManager.openScope(name);
        ScopeIF scope = scopeManager.getCurrentScope();
        semanticErrorManager.semanticDebug("Abierto ambito " + name);
        
        //******************* Ahora insertar tipos basicos en la tabla
        TypeTableIF tablaTipos = scope.getTypeTable();
        TypeSimple tipoBooleano = new TypeSimple(scope);
        tipoBooleano.setName(TypeSimple.LOGICO);
        tablaTipos.addType(tipoBooleano);
        TypeSimple tipoEntero = new TypeSimple(scope);
        tipoEntero.setName(TypeSimple.NUMERO);
        tablaTipos.addType(tipoEntero);
        TypeSimple tipoString = new TypeSimple(scope);
        tipoString.setName(TypeSimple.CADENA);
        tablaTipos.addType(tipoString);        
    :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de cabecera."); :};

tipo ::= IDENTIFICADOR:id  {: RESULT=id.getLexema();:}
        | INTEGER:t {: RESULT=TypeSimple.NUMERO; :} 
        | BOOLEAN:t {: RESULT=TypeSimple.LOGICO; :};

tipo_primitivo ::= INTEGER:t {: RESULT=TypeSimple.NUMERO; :} 
        | BOOLEAN:t {: RESULT=TypeSimple.LOGICO; :};
        
valor ::= NUMERO:n
{:
    Valor v = new Valor(scopeManager.searchType(TypeSimple.NUMERO), n.getLexema(), n.getLine());
    RESULT =v; 
:}
        | TRUE:t 
{: 
    Valor v = new Valor(scopeManager.searchType(TypeSimple.LOGICO), t.getLexema(), t.getLine());
    RESULT =v; 
:}
        | FALSE:f 
{: 
    Valor v = new Valor(scopeManager.searchType(TypeSimple.LOGICO), f.getLexema(), f.getLine());
    RESULT =v; 
:}
        | CADENA:c 
{:
    Valor v = new Valor(scopeManager.searchType(TypeSimple.CADENA), c.getLexema(), c.getLine());
    RESULT =v; 
:};             

declaraciones ::= declaracion_constantes;

declaracion_constantes ::= constante declaracion_constantes 
        | declaracion_registros;

/*******************************************************************************
CAMBIAR LA CONSTANTE EN TRES PRODUCCIONES SEGUN EL TIPO DE VALOR
1 Divido valor en valor_numerico y valor_booleano
2 Divido la produccion constante en constante:: ...valor_numeroco | ...valor_booleano
*******************************************************************************/
constante ::= lista_nombres:listaNombres DOS_PUNTOS CONSTANT ASIGNACION valor:v PUNTO_COMA
    {:
        ScopeIF scope = scopeManager.getCurrentScope();
        String nombreConstante = (String)((ListaObjetos)listaNombres).get(0);
        semanticErrorManager.semanticInfo("Declaracion de constante " + nombreConstante);
        // comprueba si la constante ha sido declarada y se encuentra en la tabla de simbolos
        if (scope.getSymbolTable().containsSymbol(nombreConstante)) {
            semanticErrorManager.semanticFatalError("Error: la constante "+nombreConstante+" ya ha sido declarada");
        } else {
            // Creo la constante en el ambito
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            SymbolConstant simboloCte = new SymbolConstant(scope,nombreConstante,v.getType());
            // La guardo en la tabla de simbolos
            tablaSimbolos.addSymbol(nombreConstante, simboloCte);
            semanticErrorManager.semanticInfo("Constante " + nombreConstante + " guardada en la tabla de simbolos");
        }
    :};
    
lista_nombres ::= IDENTIFICADOR:id SEPARADOR_COMA lista_nombres:listaNombres
    {:
        semanticErrorManager.semanticInfo("Se encuentra el nombre " + id.getLexema()); 
        semanticErrorManager.semanticInfo("Se encuentra el listado " + listaNombres.toString());
        ListaObjetos listaResultado = new ListaObjetos((ListaObjetos)listaNombres);
        listaResultado.add(id.getLexema());
        RESULT = listaResultado;
    :}
    | IDENTIFICADOR:id
    {:
        ListaObjetos listaNombres = new ListaObjetos();
        listaNombres.add(id.getLexema());
        RESULT = listaNombres;
    :};

declaracion_registros ::= registro declaracion_registros 
        | declaracion_variables;
        
registro ::= TYPE IDENTIFICADOR:idRegistro IS RECORD lista_campos:listaCamposRegistro END RECORD PUNTO_COMA
    {:
        syntaxErrorManager.syntaxInfo("Declaracion de registro " + idRegistro.getLexema() + ". Linea " + idRegistro.getLine());
        // Comprueba en la tabla de tipos si el tipo ya está declarado
        ScopeIF scope = scopeManager.getCurrentScope();
        
        TypeTableIF typeTable = scope.getTypeTable();
        
        if (typeTable.containsType(idRegistro.getLexema())) {
            semanticErrorManager.semanticFatalError("Error: el tipo "+idRegistro.getLexema()+" en la linea: "+idRegistro.getLine()+" ya ha sido declarado");
        } else {
            TypeRecord tipoRegistro = new TypeRecord(scope, idRegistro.getLexema());
            typeTable.addType(tipoRegistro);
            syntaxErrorManager.syntaxInfo("Tipo registro " + idRegistro.getLexema() + ". Añadido en la tabla de tipos");
            // Compruebo los campos
        for (int i = 0; i<listaCamposRegistro.size();i++) {
            CampoRegistro c = (CampoRegistro) listaCamposRegistro.get(i);
            SymbolVariable var = (SymbolVariable) c.getSymbol();
            if (!tipoRegistro.containsCampo(c.getNombre())) {
                semanticErrorManager.semanticInfo("Se inserta el campo " + c.getNombre() + "linea " + c.getLinea() + "... ");
                tipoRegistro.addCampo(c.getNombre(), var); 
                semanticErrorManager.semanticInfo("...OK!");                                        
            } else {
                semanticErrorManager.semanticFatalError ("El campo: " + c.getNombre() +" en " + c.getLinea() + " ya ha sido definido.");
            }
        } 
        }
        
        
    :};

/**
    CAMBIO: Elimino el no terminal campo y lo sustituyo por su produccion
**/
lista_campos ::= IDENTIFICADOR:idCampo DOS_PUNTOS tipo:tipoCampo PUNTO_COMA lista_campos:listaCampos
    {:
    // Añadir ID + tipo a lista de campos del registro registro
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF tablaTipos = scope.getTypeTable();
    SymbolIF simbolo = new SymbolVariable(scope,
                                            idCampo.getLexema(),
                                            scopeManager.searchType(tipoCampo.toString()));
    CampoRegistro campo = new CampoRegistro(idCampo.getLexema(), idCampo.getLine(), 
                                            idCampo.getColumn(), simbolo);
    semanticErrorManager.semanticInfo("Identificado el campo " + campo.getNombre() + ". ");
    if (listaCampos == null) {
        listaCampos = new ListaObjetos();
    }
    listaCampos.add(campo);
    
    RESULT = listaCampos;
    :} 
    | vacio;
   

declaracion_variables ::= variable declaracion_variables 
        | declaracion_subprogramas {:syntaxErrorManager.syntaxDebug("Declaracion subprogramas");:};
/**
    CAMBIO: sustituyo lista_nombres por su produccion
**/
variable ::= lista_nombres:objListaNombres DOS_PUNTOS tipo:objTipo PUNTO_COMA
    {:
        String tipoVariable = (String)objTipo;
        ListaObjetos listaNombres = (ListaObjetos)objListaNombres; 
        semanticErrorManager.semanticDebug("Declaracion variables de tipo " + tipoVariable);
        
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF tablaTipos = scope.getTypeTable();
        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
        
        // Si el tipo no existe, error
        if (!tablaTipos.containsType(tipoVariable)) {
            semanticErrorManager.semanticFatalError("ERROR: El tipo " 
                                + tipoVariable + 
                                " no ha sido definido en el programa");
        } else {
            semanticErrorManager.semanticDebug("Encontrado el tipo, valida que no haya nombres duplicados");
	        // Para cada nombre creo una variable
	        for (Object objeto:listaNombres.getVariables()) {
	           String nombreVar = (String)objeto;
	            semanticErrorManager.semanticInfo("Declaracion de variable " + nombreVar);
	            if (tablaSimbolos.containsSymbol(nombreVar)) {
	               semanticErrorManager.semanticFatalError("ERROR: variable duplicada " + nombreVar);
	            } else {
	               semanticErrorManager.semanticDebug("Variable valida, crea el simbolo");
	               SymbolVariable sV = new SymbolVariable(scope, nombreVar, tablaTipos.getType(tipoVariable));
	               tablaSimbolos.addSymbol(nombreVar, sV);
	            }
	        }
        }
        semanticErrorManager.semanticDebug("End declaracion variable");
    :};


declaracion_subprogramas ::= subprograma declaracion_subprogramas 
        | vacio;
        
subprograma ::= funcion
    | procedimiento; 

funcion ::= FUNCTION IDENTIFICADOR:idFuncion ABRE_PARENTESIS parametros_subprograma:listaParametros CIERRA_PARENTESIS RETURN tipo_primitivo:tipoRetorno
{:
    String nombreFuncion = idFuncion.getLexema();
        
    // Comprueba si la funcion ha sido declarada
    if (!(scopeManager.containsSymbol(nombreFuncion)
        && scopeManager.containsType(nombreFuncion))) {
        semanticErrorManager.semanticInfo("Declaracion de funcion " + nombreFuncion 
            + " en linea " + idFuncion.getLine());
            
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF tablaTipos = scope.getTypeTable();
        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
        //Creo un tipo y un simbolo para la funcion y los añado a la tabla
        TypeFunction tipoFuncion = new TypeFunction(scope, nombreFuncion);
        TypeIF tipoResultado = scopeManager.searchType((String)tipoRetorno);
            
        semanticErrorManager.semanticInfo("Retorna " + tipoResultado.getName());
        tipoFuncion.setTipoResultado(tipoResultado);
        tablaTipos.addType(nombreFuncion, tipoFuncion);
        SymbolFunction simboloFuncion = new SymbolFunction(scope, nombreFuncion, tipoFuncion);
        tablaSimbolos.addSymbol(nombreFuncion, simboloFuncion);
            
        // Abro un nuevo ambito para la funcion, con una nueva tabla simbolos y tipos
        semanticErrorManager.semanticInfo("Nuevo ambito " + nombreFuncion);
            
        ScopeIF scopeFuncion = scopeManager.openScope(nombreFuncion);
        TypeTableIF tablaTiposFuncion = scopeFuncion.getTypeTable();
        SymbolTableIF tablaSimbolosFuncion = scopeFuncion.getSymbolTable();
            
        for (SymbolParameter parametro:((ListaParametrosDeclaracion)listaParametros).getListaParametros()) {
            semanticErrorManager.semanticInfo("Declaracion de parametro " + parametro.getName() 
                                + " de tipo " + parametro.getType().getName());
            tablaSimbolosFuncion.addSymbol(parametro.getName(),parametro);
            tipoFuncion.addTipoParametro(parametro.getType());
        }
    } else {
        semanticErrorManager.semanticFatalError("ERROR: Funcion ya declarada " + nombreFuncion
            +" en linea: "+idFuncion.getLine());        
    }
        
:} IS declaraciones cuerpo_funcion;

parametros_subprograma ::= lista_nombres:listaNombres DOS_PUNTOS tipo:tipo PUNTO_COMA parametros_subprograma:listaParametrosPrevios
	    {:
		ScopeIF scope = scopeManager.getCurrentScope();
		TypeTableIF tablaTipos = scope.getTypeTable();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		
		if (!scopeManager.containsType((String)tipo)) {
		   semanticErrorManager.semanticFatalError("ERROR: tipo desconocido " + (String)tipo);
		} else {
		   ListaParametrosDeclaracion listaParametros = new ListaParametrosDeclaracion(((ListaParametrosDeclaracion)listaParametrosPrevios).getListaParametros());
		   // Para cada nombre creo un parametro
		   for (Object objeto:((ListaObjetos)listaNombres).getVariables()) {
		       String nombreParametro = (String)objeto;
		       semanticErrorManager.semanticInfo("Declaracion de parametro " + nombreParametro + " tipo " + (String)tipo);
		       if (scopeManager.containsSymbol(nombreParametro)) {
		           semanticErrorManager.semanticFatalError("ERROR: parametro duplicado " + nombreParametro);
	           } else {
	               semanticErrorManager.semanticDebug("Parametro valida, crea el simbolo");
	               SymbolParameter sP = new SymbolParameter(scope, nombreParametro, tablaTipos.getType((String)tipo));
	               tablaSimbolos.addSymbol(nombreParametro, sP);
	               listaParametros.getListaParametros().add(sP);
	           }
	        }
	        RESULT = listaParametros;
	    }	    
	    :}
        | lista_nombres:listaNombres DOS_PUNTOS tipo:tipo 
        {:
            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
            if (!scopeManager.containsType((String)tipo)) {
                semanticErrorManager.semanticFatalError("ERROR: tipo desconocido " + (String)tipo);
            } else {
	            ListaParametrosDeclaracion listaParametros = new ListaParametrosDeclaracion();
	            // Para cada nombre creo un parametro
	            for (Object objeto:((ListaObjetos)listaNombres).getVariables()) {
	               String nombreParametro = (String)objeto;
	                semanticErrorManager.semanticInfo("Declaracion de parametro " + nombreParametro);
	                if (scopeManager.containsSymbol(nombreParametro)) {
	                   semanticErrorManager.semanticFatalError("ERROR: parametro duplicado " + nombreParametro);
	                } else {
	                   semanticErrorManager.semanticDebug("Parametro valida, crea el simbolo");
	                   SymbolParameter sP = new SymbolParameter(scope, nombreParametro, tablaTipos.getType((String)tipo));
	                   tablaSimbolos.addSymbol(nombreParametro, sP);
	                   listaParametros.getListaParametros().add(sP);
	                }
	            }
	            RESULT = listaParametros;
            }        
        :}
        | vacio;
        
procedimiento ::= PROCEDURE IDENTIFICADOR:idProcedimiento ABRE_PARENTESIS parametros_subprograma:listaParametros CIERRA_PARENTESIS
    {:
        // El procedimiento es igual que la funcion, pero crea un tipo procedure que no tiene retorno
        String nombreProcedimiento = idProcedimiento.getLexema();
        
        // Comprueba si la funcion ha sido declarada
        if (!(scopeManager.containsSymbol(nombreProcedimiento)
            && scopeManager.containsType(nombreProcedimiento))) {
            semanticErrorManager.semanticInfo("Declaracion de procedimiento " + nombreProcedimiento 
                                            + " en linea " + idProcedimiento.getLine());
            
            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
            //Creo un tipo y un simbolo para el procedimiento y los añado a la tabla
            TypeProcedure tipoProcedimiento = new TypeProcedure(scope, nombreProcedimiento);
            
            tablaTipos.addType(nombreProcedimiento, tipoProcedimiento);
            SymbolProcedure simboloProcedimiento = new SymbolProcedure(scope, nombreProcedimiento, tipoProcedimiento);
            tablaSimbolos.addSymbol(nombreProcedimiento, simboloProcedimiento);
            
            // Abro un nuevo ambito para el procedimiento, con una nueva tabla simbolos y tipos
            semanticErrorManager.semanticInfo("Nuevo ambito " + nombreProcedimiento);
            ScopeIF scopeProcedimiento = scopeManager.openScope(nombreProcedimiento);
            TypeTableIF tablaTiposProcedimiento = scopeProcedimiento.getTypeTable();
            SymbolTableIF tablaSimbolosProcedimiento = scopeProcedimiento.getSymbolTable();
            
            // Almaceno los parametros en la tabla de simbolos y la de tipos
            for (SymbolParameter parametro:((ListaParametrosDeclaracion)listaParametros).getListaParametros()) {
                semanticErrorManager.semanticInfo("Declaracion de parametro " + parametro.getName() 
                                + " de tipo " + parametro.getType().getName());
                tablaSimbolosProcedimiento.addSymbol(parametro.getName(),parametro);
                tipoProcedimiento.addTipoParametro(parametro.getType());
            }
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Procedimiento ya declarada " + nombreProcedimiento
                                                    +" en linea: "+idProcedimiento.getLine());        }
        
    :}  IS declaraciones cuerpo;

cuerpo_funcion::= BEGIN lista_sentencias_funcion END IDENTIFICADOR PUNTO_COMA
{:
    semanticErrorManager.semanticDebug("Cierro ambito ");
    scopeManager.closeScope();
:};

lista_sentencias_funcion ::=  sentencia_funcion PUNTO_COMA lista_sentencias_funcion |  vacio;

sentencia_funcion ::= sentencia | sentencia_return;

sentencia_return ::= RETURN expresion;



cuerpo ::=  BEGIN lista_sentencias END IDENTIFICADOR PUNTO_COMA
    {:
        semanticErrorManager.semanticDebug("Cierro ambito ");
        scopeManager.closeScope();
    :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en cuerpo de procedimiento."); :};
 


        
/*******************************************************************************
    CAMBIO: TRUE,FALSE pasan a valor_booleano
    NUMERO pasa a valor_numerico
*******************************************************************************/
expresion ::= expresion:exp1 PLUS:operador expresion:exp2
    {:
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        semanticErrorManager.semanticDebug("Expresion " + type1.getName() + " + " + type2.getName());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = type1;   // No hay conversion de tipos
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
            semanticErrorManager.semanticDebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}
        | expresion:exp1 MAYOR:operador expresion:exp2
    {:
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        semanticErrorManager.semanticDebug("Expresion " + type1.getName() + " > " + type2.getName());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = scopeManager.searchType(TypeSimple.LOGICO);
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
            semanticErrorManager.semanticDebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}            
        | expresion:exp1 IGUAL:operador expresion:exp2
    {:
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        semanticErrorManager.semanticDebug("Expresion " + type1.getName() + " == " + type2.getName());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = scopeManager.searchType(TypeSimple.LOGICO);
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
            semanticErrorManager.semanticDebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}         
        | expresion:exp1 OR:operador expresion:exp2 
    {:
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        semanticErrorManager.semanticDebug("Expresion " + type1.getName() + " OR " + type2.getName());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = scopeManager.searchType(TypeSimple.LOGICO);
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
            semanticErrorManager.semanticDebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}            
        | ABRE_PARENTESIS:a expresion:exp CIERRA_PARENTESIS:b
{:
    Expresion e = (Expresion)exp;
    TypeIF tipoExpresion = e.getType();
    String lexema = a.getLexema() + " " + e.getLexema() + " " + b.getLexema();
    semanticErrorManager.semanticDebug("Expresion " + lexema);
    Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
    RESULT = expresionResultado;
:}        
        | llamada_subprograma:l
{:  
    
    if (l != null) {
        // Si existe devolucion es que es una funcion y no un procedimiento
        Expresion expresionResultado = new Expresion(l.getType(), l.getLexema());
        RESULT = expresionResultado;
    } else {
       semanticErrorManager.semanticFatalError("ERROR: uso de un procedimiento en una expresion "); 
    }
:}        
        | referencia:r
{:
    TypeIF tipo = r.getType();
    String lexema = r.getLexema();
    RESULT = new Expresion(tipo, lexema);
:}              
        | valor:valor
{:
    Expresion expresionResultado = new Expresion(valor.getType(), valor.getLexema());
    RESULT = expresionResultado;
:};

referencia ::= IDENTIFICADOR:id 
{:
    String name = id.getLexema();
    if (scopeManager.containsSymbol(name)) {
        SymbolIF simbolo = scopeManager.searchSymbol(name);
        TypeIF tipo = simbolo.getType();
        Referencia r = new Referencia(tipo, name, id.getLine()); 
        RESULT = r;
    } else {
       semanticErrorManager.semanticFatalError("ERROR: uso de una referencia desconocida " + id.getLine() + " " + name);         
    }
:}
        | acceso_registro:a
{:
    RESULT = a;
:};

acceso_registro ::= referencia:registro ACCESO IDENTIFICADOR:campo
{:
    String nombreRegistro = registro.getLexema();
    String nombreCampo = campo.getLexema();
    TypeIF tipoRegistro = registro.getType();
    if (tipoRegistro instanceof TypeRecord) {
        TypeRecord tRec = (TypeRecord)tipoRegistro;
        if (tRec.containsCampo(nombreCampo)) {
            TypeIF innerType = tRec.getCampo(nombreCampo).getType();
            RESULT = new Referencia(innerType, nombreRegistro + "." + nombreCampo, campo.getLine());
        } else {
            semanticErrorManager.semanticFatalError("ERROR: campo no declarado " + nombreCampo);
        }
    } else {
        semanticErrorManager.semanticFatalError("ERROR: tipo no declarado " + tipoRegistro.getName());
    }
:};

       
lista_sentencias ::=  sentencia PUNTO_COMA lista_sentencias 
        |  vacio;

sentencia ::= sentencia_entrada_salida 
        | sentencia_if
        | sentencia_for
        | sentencia_asignacion
        | llamada_subprograma;

sentencia_if ::= IF expresion:objExp THEN lista_sentencias END IF
{:
    Expresion expCondicion = (Expresion)objExp;
    if (!expCondicion.getType().getName().equalsIgnoreCase(TypeSimple.LOGICO)) {
        semanticErrorManager.semanticFatalError("ERROR: la condicion debe devolver un tipo boolean" );
    }
:}
        | IF expresion:objExp THEN lista_sentencias ELSE lista_sentencias END IF
{:
    Expresion expCondicion = (Expresion)objExp;
    if (!expCondicion.getType().getName().equalsIgnoreCase(TypeSimple.LOGICO)) {
        semanticErrorManager.semanticFatalError("ERROR: la condicion debe devolver un tipo boolean" );
    }
:}        
        | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia if"); :};


sentencia_for ::=  FOR IDENTIFICADOR:indice IN expresion:expInicio DELIMITADOR_RANGO expresion:expFin LOOP lista_sentencias END LOOP
{:
    //Indice debe corresponder con una variable de tipo entero
    List<SymbolIF> posiblesIndices = scopeManager.searchSymbols(indice.getLexema());
    if (posiblesIndices == null || posiblesIndices.size() == 0) {
        semanticErrorManager.semanticFatalError("ERROR: simbolo no declarado en indice, linea: " + indice.getLine());
    } else {
        // Compruebo que el tipo de la variable sea entero
        SymbolVariable varIndex = null;
        TypeIF tipoEntero = scopeManager.searchType(TypeSimple.NUMERO);
        for (SymbolIF posibleIndex:posiblesIndices) {
            if (posibleIndex.getType().equals(tipoEntero)) {
                varIndex = (SymbolVariable)posibleIndex;
            }
        }
        if (varIndex == null) {
            semanticErrorManager.semanticFatalError("ERROR: el indice debe ser una variable de tipo entero, linea: " + indice.getLine());
        } else {
            if (!expInicio.getType().equals(tipoEntero) || !expFin.getType().equals(tipoEntero)) {
                semanticErrorManager.semanticFatalError("ERROR: el rango de la sentencia for debe ser expresiones de tipo entero, linea: " + indice.getLine());
            }
        }
    }
:};      
        
sentencia_asignacion ::= referencia:referencia ASIGNACION expresion:expresion
{:
    // Debo comprobar que tanto referencia como expresion coinciden en tipo y que este es uno de los tipos simples
    if (!(referencia.getType() instanceof TypeSimple)) {
        semanticErrorManager.semanticFatalError("ERROR: no se permiten asignaciones a tipos compuestos, linea: " + referencia.getLine());
    } else if (!referencia.getType().equals(expresion.getType())) {
        semanticErrorManager.semanticFatalError("ERROR: tipos distintos en asignacion, linea: " + referencia.getLine()); 
    }
:};

sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS parametro:param CIERRA_PARENTESIS
{:
    Parametro parametro = param;
    if (!(parametro.getType() instanceof TypeSimple)) {
        semanticErrorManager.semanticFatalError("ERROR: parametros no compatibles en put_line " + parametro.getLexema() + ", linea: " + parametro.getLine());
    }
:};

parametro ::= valor:valor
{:
    Parametro parametro =  new Parametro(valor.getType(), valor.getLexema(), valor.getLine());
    RESULT = parametro;
:}
        | referencia:referencia
{:
    Parametro parametro = new Parametro(referencia.getType(),referencia.getLexema(),referencia.getLine());
    RESULT = parametro;
:};

llamada_subprograma ::= IDENTIFICADOR:id ABRE_PARENTESIS lista_parametros:pa CIERRA_PARENTESIS
{:
    String name = id.getLexema();
    if (!scopeManager.containsSymbol(name)) {
        semanticErrorManager.semanticFatalError("ERROR: subprograma desconocido " + name + ", linea: " + id.getLine());    
    } else {
        SymbolIF s = scopeManager.searchSymbol(name);
        if (s instanceof SymbolFunction) {
            // Se trata de una funcion
            SymbolFunction sf = (SymbolFunction)s;
            TypeFunction tf = (TypeFunction)sf.getType();
            
            List<TypeIF> paramInvocacion = pa.getParameterTypes();
            List<TypeIF> paramTeoricos = tf.getTipoParametros();
            if (paramInvocacion.equals(paramTeoricos)) {
                //OK
                TypeIF returnType = tf.getTipoResultado();
                Expresion e = new Expresion(returnType, name);
                RESULT = e;
            } else {
                semanticErrorManager.semanticFatalError("ERROR: parametros erroneos en invocacion a funcion " 
                    + name + ", linea: " + id.getLine());    
            }
        } else if (s instanceof SymbolProcedure) {
            // Se trata de un procedimiento
            // Se trata de una funcion
            SymbolProcedure sf = (SymbolProcedure)s;
            TypeProcedure tf = (TypeProcedure)sf.getType();
            
            List<TypeIF> paramInvocacion = pa.getParameterTypes();
            List<TypeIF> paramTeoricos = tf.getTipoParametros();
            if (!paramInvocacion.equals(paramTeoricos)) {
                semanticErrorManager.semanticFatalError("ERROR: parametros erroneos en invocacion a procedimiento " + name + ", linea: " + id.getLine());    
            }
        } else {
            semanticErrorManager.semanticFatalError("ERROR: El simbolo " + name 
                + " no se corresponde con un subprograma, linea: " + id.getLine());
        }
    }
:};

lista_parametros ::= expresion:e SEPARADOR_COMA lista_parametros:lista
{:
    lista.addParameterType(e.getType());
    RESULT = lista;
:}
        | expresion:e
{:
	ListaParametrosEjecucion lista = new ListaParametrosEjecucion();
	lista.addParameterType(e.getType());
    RESULT = lista;
:}  
        | vacio
{:
    ListaParametrosEjecucion lista = new ListaParametrosEjecucion();
    RESULT = lista;
:};