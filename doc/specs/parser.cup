package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;
import compiler.code.translator.*;

// Declaración del código de usuario

action code {:
    
    SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
    SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
    ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
    FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}  

parser code {:
    SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
    
    public void syntax_error(Symbol symbol)
    { 
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxError ("Error sintactico", token);     
    }
        
    public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
    {   
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxFatalError ("Error fatal", token);
    }
:}

// Declaración de terminales (Ejemplo)

// Palabras reservadas
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;

// OPERADORES
terminal Token PLUS;
terminal Token MAYOR;
terminal Token IGUAL;
terminal Token ASIGNACION;
terminal Token ACCESO;

// DELIMITADORES
terminal Token ABRE_PARENTESIS;
terminal Token CIERRA_PARENTESIS;
terminal Token DELIMITADOR_RANGO;
terminal Token SEPARADOR_COMA;
terminal Token PUNTO_COMA;
terminal Token DOS_PUNTOS;

// OTROS
terminal Token NUMERO;
terminal Token IDENTIFICADOR;
terminal Token CADENA;

// Declaración de no terminales
// no modificar los propuestos

non terminal            program;
non terminal Axiom      axiom;

non terminal    vacio;
non terminal    cabecera;
non terminal    Declaraciones declaraciones;
non terminal    Declaraciones declaracion_constantes;
non terminal    Declaraciones declaracion_registros;
non terminal    Declaraciones declaracion_variables;
non terminal    Declaraciones declaracion_subprogramas;
non terminal    lista_nombres;
non terminal    Declaraciones constante;
non terminal    Valor   valor;

non terminal    registro;
non terminal    ListaObjetos lista_campos;
non terminal    tipo;

non terminal    Declaraciones variable;
non terminal    Cuerpo cuerpo;
non terminal    ListaSentencias lista_sentencias;
non terminal    sentencia;
non terminal    SentenciaPutLine sentencia_entrada_salida;
non terminal    SentenciaAsignacion sentencia_asignacion;
non terminal    sentencia_if;
non terminal    sentencia_for;
non terminal    Referencia referencia;
non terminal    Referencia acceso_registro;
non terminal    Expresion expresion;
non terminal    Parametro parametro;
non terminal    LlamadaSubprograma llamada_subprograma;
non terminal    ListaParametrosEjecucion lista_parametros;
non terminal    DeclaracionSubprograma subprograma;
non terminal    DeclaracionSubprograma funcion;
non terminal    DeclaracionSubprograma procedimiento;
non terminal    ListaParametrosDeclaracion parametros_subprograma;
non terminal    tipo_primitivo;
non terminal    CuerpoFuncion cuerpo_funcion;
non terminal    ListaSentenciasReturn lista_sentencias_funcion;
non terminal    Expresion sentencia_funcion;
non terminal    Expresion sentencia_return;

// Declaración de relaciones de precedencia, SEPARADOS POR COMAS

precedence left OR;
precedence left IGUAL;
precedence left MAYOR;
precedence left PLUS;
precedence left ACCESO, ABRE_PARENTESIS, CIERRA_PARENTESIS;

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {:
        List<ScopeIF> scopes = scopeManager.getAllScopes();
        semanticErrorManager.semanticDebug("Numero de entornos: " + scopes.size());
		MemoryManager.assignAddresses();
		
        ScopeIF scopeActual = null;
        for (ScopeIF scope:scopes) {
			if (scope.getLevel() == 0) {
				scopeActual = scope;
			}
		}
        
        IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeActual);
        cb.addQuadruple("INICIO", null,MemoryManager.getgAddress(), ax.getLabel());
        
        List intermediateCode = ax.getIntermediateCode();
        cb.addQuadruples(intermediateCode);
		cb.addQuadruple (InstructionSet.FINAL);
        syntaxErrorManager.syntaxInfo ("Codigo intermedio generado " + cb.create());

        ExecutionEnvironmentEns2001 e = new ExecutionEnvironmentEns2001();
        finalCodeFactory.setEnvironment(e); 
          
        finalCodeFactory.create(cb.create());               
        
        syntaxErrorManager.syntaxInfo ("Codigo intermedio generado  " + cb.create());
        syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= cabecera:apertura declaraciones:declaraciones cuerpo:cierre
{:
    semanticErrorManager.semanticDebug("1 axiom ::= cabecera:apertura declaraciones cuerpo:cierre");
    String idApertura = (String)apertura;
    String idCierre = cierre.getIdProcedimiento();
    if (!idApertura.equalsIgnoreCase(idCierre)) {
        semanticErrorManager.semanticFatalError("ERROR semantico: el identificador de apertura debe ser el mismo que el de cierre: "
            + idApertura + " " + idCierre);
    }
    
    Axiom ax = new Axiom();
	LabelFactoryIF labelFactory = new LabelFactory ();
    LabelIF label = labelFactory.create (idApertura);
	ax.setLabel(label);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	if(declaraciones != null) {
		ax.getIntermediateCode().addAll(declaraciones.getIntermediateCode());
    }            
    cb.addQuadruple(InstructionSet.LABEL, label, 0);
    ax.getIntermediateCode().addAll(cb.create());
    ax.getIntermediateCode().addAll(cierre.getIntermediateCode());
	scopeManager.closeScope();
    RESULT = ax;
:}
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

vacio ::= {:
    syntaxErrorManager.syntaxDebug ("2: VACIO");
:};

cabecera ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS CIERRA_PARENTESIS IS
    {:
		semanticErrorManager.semanticDebug("3: CABECERA");
        //Crear el ámbito global del programa asociado al nombre del procedimiento.
        String name = id.getLexema();
        scopeManager.openScope(name);

        ScopeIF scope = null;
		try {
			scope = scopeManager.getCurrentScope();
		} catch (Exception e) {
			semanticErrorManager.semanticError("Error en 3: CABECERA");
			semanticErrorManager.semanticError(e.getMessage());
		}
        
        //******************* Ahora insertar tipos basicos en la tabla
		
        TypeTableIF tablaTipos = scope.getTypeTable();
        TypeSimple tipoBooleano = new TypeSimple(scope);
        tipoBooleano.setName(TypeSimple.LOGICO);
        tablaTipos.addType(tipoBooleano);
        TypeSimple tipoEntero = new TypeSimple(scope);
        tipoEntero.setName(TypeSimple.NUMERO);
        tablaTipos.addType(tipoEntero);
        TypeSimple tipoString = new TypeSimple(scope);
        tipoString.setName(TypeSimple.CADENA);
        tablaTipos.addType(tipoString);
        RESULT = name;        
    :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de cabecera."); :};

tipo ::= IDENTIFICADOR:id  
{:
    semanticErrorManager.semanticDebug("4: tipo ::= IDENTIFICADOR:id  ");
    // semanticErrorManager.semanticInfo("Tipo " + id.getLexema() + ", linea:" + id.getLine());
    RESULT=id.getLexema();
:}
        | INTEGER:t 
{:
	semanticErrorManager.semanticDebug("5: tipo ::= INTEGER:t");
    // semanticErrorManager.semanticInfo("Tipo " + t.getLexema() + ", linea:" + t.getLine());
    RESULT=TypeSimple.NUMERO; 
:} 
        | BOOLEAN:t 
{:
semanticErrorManager.semanticDebug("6");
    // semanticErrorManager.semanticInfo("Tipo " + t.getLexema() + ", linea:" + t.getLine());
    RESULT=TypeSimple.LOGICO; 
:};

tipo_primitivo ::= INTEGER:t 
{: 
semanticErrorManager.semanticDebug("7: tipo_primitivo ::= INTEGER:t ");
//    semanticErrorManager.semanticInfo("Tipo primitivo " + t.getLexema() + ", linea:" + t.getLine());
    RESULT=TypeSimple.NUMERO; 
:} 
        | BOOLEAN:t 
{: 
semanticErrorManager.semanticDebug("8: tipo_primitivo ::= BOOLEAN:t  ");
//    semanticErrorManager.semanticInfo("Tipo primitivo " + t.getLexema() + ", linea:" + t.getLine());
    RESULT=TypeSimple.LOGICO; 
:};
        
valor ::= NUMERO:n
{:
	semanticErrorManager.semanticDebug("9: valor ::= NUMERO:n");
    //    semanticErrorManager.semanticInfo("Valor numerico " + n.getLexema() + ", linea:" + n.getLine());
    Valor v = new Valor(scopeManager.searchType(TypeSimple.NUMERO), n.getLexema(), n.getLine(), new Value(Integer.parseInt(n.getLexema())));
    RESULT =v; 
:}
        | TRUE:t 
{:
	semanticErrorManager.semanticDebug("10: valor ::= TRUE:t ");
    //    semanticErrorManager.semanticInfo("Valor logico " + t.getLexema() + ", linea:" + t.getLine()); 
    Valor v = new Valor(scopeManager.searchType(TypeSimple.LOGICO), t.getLexema(), t.getLine(), new Value(Boolean.TRUE));
    RESULT =v; 
:}
        | FALSE:f 
{:
	semanticErrorManager.semanticDebug("11 valor ::= FALSE:f  ");
    //    semanticErrorManager.semanticInfo("Valor logico " + f.getLexema() + ", linea:" + f.getLine()); 
    Valor v = new Valor(scopeManager.searchType(TypeSimple.LOGICO), f.getLexema(), f.getLine(), new Value(Boolean.FALSE));
    RESULT =v; 
:}
        | CADENA:c 
{:
	semanticErrorManager.semanticDebug("12: CADENA:c ");
    //    semanticErrorManager.semanticInfo("Valor string " + c.getLexema() + ", linea:" + c.getLine());
    Valor v = new Valor(scopeManager.searchType(TypeSimple.CADENA), c.getLexema(), c.getLine(), new Value(c.getLexema()));
    RESULT =v; 
:};             

declaraciones ::= declaracion_constantes:dc
{:
	semanticErrorManager.semanticDebug("12b: declaraciones ::= declaracion_constantes " + dc);
	RESULT =dc;
:};

declaracion_constantes ::= constante:c declaracion_constantes:declaraciones 
{:
	semanticErrorManager.semanticDebug("12c: declaracion_constantes ::= constante declaracion_constantes ");
	RESULT=declaraciones.addDeclaracion(c);
:}
        | declaracion_registros:dr
{:
	semanticErrorManager.semanticDebug("12d: declaracion_constantes ::= declaracion_registros");
	RESULT = dr;
:};


constante ::= lista_nombres:listaNombres DOS_PUNTOS CONSTANT ASIGNACION valor:v PUNTO_COMA
    {:
    semanticErrorManager.semanticDebug("13");
        ScopeIF scope = scopeManager.getCurrentScope();
        String nombreConstante = (String)((ListaObjetos)listaNombres).get(0);
        //    semanticErrorManager.semanticInfo("Declaracion de constante " + nombreConstante);
        // comprueba si la constante ha sido declarada y se encuentra en la tabla de simbolos
        if (scope.getSymbolTable().containsSymbol(nombreConstante)) {
            semanticErrorManager.semanticFatalError("Error: la constante "+nombreConstante+" ya ha sido declarada");
        } else {
            // Creo la constante en el ambito
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            SymbolConstant simboloCte = new SymbolConstant(scope,nombreConstante,v.getType());
			simboloCte.setValue(v.getValue());
            // La guardo en la tabla de simbolos
            tablaSimbolos.addSymbol(nombreConstante, simboloCte);
            
			Declaraciones dc = new Declaraciones();
			RESULT = dc;
        }
    :};
    
lista_nombres ::= IDENTIFICADOR:id SEPARADOR_COMA lista_nombres:listaNombres
    {:
		semanticErrorManager.semanticDebug("14");
        ListaObjetos listaResultado = new ListaObjetos((ListaObjetos)listaNombres);
        listaResultado.add(id.getLexema().toUpperCase());
        //    semanticErrorManager.semanticInfo("Se encuentra el nombre " + id.getLexema()); 
        //    semanticErrorManager.semanticInfo("Se encuentra el listado " + listaNombres.toString());
        RESULT = listaResultado;
    :}
    | IDENTIFICADOR:id
    {:
		semanticErrorManager.semanticDebug("15: Lista_nombres ::= identificador");
        // semanticErrorManager.semanticInfo("Se encuentra el identificador " + id.getLexema() + ", Linea: " + id.getLexema());
        ListaObjetos listaNombres = new ListaObjetos();
        listaNombres.add(id.getLexema().toUpperCase());
        RESULT = listaNombres;
    :};

declaracion_registros ::= registro declaracion_registros:dr 
{:
	semanticErrorManager.semanticDebug("15b: declaracion_registros ::= registro declaracion_registros");
	RESULT = dr;
:}
        | declaracion_variables:dv
{:
	semanticErrorManager.semanticDebug("15c: declaracion_registros ::= declaracion_variables");
	RESULT = dv;
:};
        
registro ::= TYPE IDENTIFICADOR:idRegistro IS RECORD lista_campos:listaCamposRegistro END RECORD PUNTO_COMA
    {:
    semanticErrorManager.semanticDebug("16");
        //syntaxErrorManager.syntaxInfo("Declaracion de registro " + idRegistro.getLexema() + ". Linea " + idRegistro.getLine());
        // Comprueba en la tabla de tipos si el tipo ya está declarado
        ScopeIF scope = scopeManager.getCurrentScope();
        
        TypeTableIF typeTable = scope.getTypeTable();
        
        if (typeTable.containsType(idRegistro.getLexema().toUpperCase())) {
            semanticErrorManager.semanticFatalError("Error: el tipo "+idRegistro.getLexema()+" en la linea: "+idRegistro.getLine()+" ya ha sido declarado");
        } else {
            TypeRecord tipoRegistro = new TypeRecord(scope, idRegistro.getLexema().toUpperCase());
            typeTable.addType(tipoRegistro);
            //syntaxErrorManager.syntaxInfo("Tipo registro " + idRegistro.getLexema() + ". Añadido en la tabla de tipos");
            // Compruebo los campos
            for (int i = 0; i<listaCamposRegistro.size();i++) {
                CampoRegistro c = (CampoRegistro) listaCamposRegistro.get(i);
                SymbolVariable var = (SymbolVariable) c.getSymbol();
                if (!tipoRegistro.containsCampo(c.getNombre().toUpperCase())) {
                    tipoRegistro.addCampo(c.getNombre().toUpperCase(), var); 
                    //    semanticErrorManager.semanticInfo("Se inserta el campo " + c.getNombre() 
                   //     + ",linea: " + c.getLinea() + " en el registro " + idRegistro.getLexema());                                        
                } else {
                    semanticErrorManager.semanticFatalError ("El campo: " + c.getNombre() +" en " + c.getLinea() + " ya ha sido definido.");
                }
            } 
        }
        
        
    :};

lista_campos ::= IDENTIFICADOR:idCampo DOS_PUNTOS tipo:tipoCampo PUNTO_COMA lista_campos:listaCampos
{:
semanticErrorManager.semanticDebug("17");
    // Añadir ID + tipo a lista de campos del registro registro
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF tablaTipos = scope.getTypeTable();
    SymbolIF simbolo = new SymbolVariable(scope,
                                            idCampo.getLexema().toUpperCase(),
                                            scopeManager.searchType(tipoCampo.toString().toUpperCase()));
    CampoRegistro campo = new CampoRegistro(idCampo.getLexema().toUpperCase(), idCampo.getLine(), 
                                            idCampo.getColumn(), simbolo);
    //    semanticErrorManager.semanticInfo("Identificado el campo " + campo.getNombre() + ", añado a la lista ");
    if (listaCampos == null) {
        listaCampos = new ListaObjetos();
    }
    listaCampos.add(campo);
    
    RESULT = listaCampos;
:} 
    | vacio;
   

declaracion_variables ::= variable:v declaracion_variables:declaraciones
{:
	semanticErrorManager.semanticDebug("18: declaracion_variables ::= variable declaracion_variables");
	RESULT=declaraciones.addDeclaracion(v);
    //    semanticErrorManager.semanticInfo("Comienza declaracion de variables ");
:}
        | declaracion_subprogramas:declaracionSubprogramas
{:
	RESULT=declaracionSubprogramas;
:};

variable ::= lista_nombres:objListaNombres DOS_PUNTOS tipo:objTipo PUNTO_COMA
{:
	semanticErrorManager.semanticDebug("19: variable ::= lista_nombres:objListaNombres DOS_PUNTOS tipo:objTipo PUNTO_COMA");
    String tipoVariable = ((String)objTipo).toUpperCase();
    ListaObjetos listaNombres = (ListaObjetos)objListaNombres; 
//    semanticErrorManager.semanticDebug("Declaracion variables de tipo " + tipoVariable);
        
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF tablaTipos = scope.getTypeTable();
    SymbolTableIF tablaSimbolos = scope.getSymbolTable();
        
    // Si el tipo no existe, error
    if (!scopeManager.containsType(tipoVariable)) {
        semanticErrorManager.semanticFatalError("ERROR: El tipo " 
                                + tipoVariable + 
                                " no ha sido definido en el programa");
    } else {
        //    semanticErrorManager.semanticDebug("Encontrado el tipo, valida que no haya nombres duplicados");
	    // Para cada nombre creo una variable
	    for (Object objeto:listaNombres.getVariables()) {
            String nombreVar = ((String)objeto).toUpperCase();
            //    semanticErrorManager.semanticInfo("Declaracion de variable " + nombreVar);
            if (tablaSimbolos.containsSymbol(nombreVar)) {
                semanticErrorManager.semanticFatalError("ERROR: variable duplicada " + nombreVar);
            } else {
	           //    semanticErrorManager.semanticDebug("Variable valida, crea el simbolo " + nombreVar + " de tipo " + tipoVariable);
	           SymbolVariable sV = new SymbolVariable(scope, nombreVar, scopeManager.searchType(tipoVariable));
	           //    semanticErrorManager.semanticInfo("Símbolo " + sV);
	           tablaSimbolos.addSymbol(nombreVar, sV);
            }
        }
    }
:};


declaracion_subprogramas ::= subprograma:s declaracion_subprogramas:ds
{:
	semanticErrorManager.semanticDebug("20");
    semanticErrorManager.semanticInfo("Comienza declaracion de subprogramas ");
    if (ds == null) {
        ds = new Declaraciones();
    }
	RESULT = ds.addDeclaracionSubprograma(s);
:} 
        | vacio;
        
subprograma ::= funcion:f
{:
	RESULT = f;
:}	
    | procedimiento:p
	{:
	RESULT = p;
:}	; 

funcion ::= FUNCTION IDENTIFICADOR:idFuncion ABRE_PARENTESIS parametros_subprograma:listaParametros CIERRA_PARENTESIS RETURN tipo_primitivo:tipoRetorno
{:
semanticErrorManager.semanticDebug("21");
    String nombreFuncion = (idFuncion.getLexema()).toUpperCase();
        
    // Comprueba si la funcion ha sido declarada
    if (!(scopeManager.containsSymbol(nombreFuncion)
        && scopeManager.containsType(nombreFuncion))) {
        //    semanticErrorManager.semanticInfo("Declaracion de funcion " + nombreFuncion 
        //    + " en linea " + idFuncion.getLine());
            
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF tablaTipos = scope.getTypeTable();
        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
        //Creo un tipo y un simbolo para la funcion y los añado a la tabla
        TypeFunction tipoFuncion = new TypeFunction(scope, nombreFuncion.toUpperCase());
		semanticErrorManager.semanticInfo("Crea el tipo para la funcion " + tipoFuncion);
        TypeIF tipoResultado = scopeManager.searchType(((String)tipoRetorno).toUpperCase());
            
        //    semanticErrorManager.semanticInfo("Retorna " + tipoResultado.getName());
        tipoFuncion.setTipoResultado(tipoResultado);
        tablaTipos.addType(nombreFuncion, tipoFuncion);
		semanticErrorManager.semanticInfo("Guarda la funcion en la tabla de tipos " + tablaTipos);
        SymbolFunction simboloFuncion = new SymbolFunction(scope, nombreFuncion, tipoFuncion);
        tablaSimbolos.addSymbol(nombreFuncion, simboloFuncion);
            
        // Abro un nuevo ambito para la funcion, con una nueva tabla simbolos y tipos
        semanticErrorManager.semanticInfo("Nuevo ambito " + nombreFuncion);
            
        ScopeIF scopeFuncion = scopeManager.openScope(nombreFuncion);
        TypeTableIF tablaTiposFuncion = scopeFuncion.getTypeTable();
        SymbolTableIF tablaSimbolosFuncion = scopeFuncion.getSymbolTable();
        
        for (SymbolParameter parametro:listaParametros.getListaParametros()) {
            tablaSimbolosFuncion.addSymbol(parametro.getName().toUpperCase(),parametro);
            tipoFuncion.addTipoParametro(parametro.getType());
			tipoFuncion.addParametro(parametro);
        }
		semanticErrorManager.semanticInfo(tipoFuncion);
    } else {
        semanticErrorManager.semanticFatalError("ERROR: Funcion ya declarada " +  idFuncion.getLexema()
            +" en linea: "+idFuncion.getLine());        
    }
        
:} IS declaraciones:declaraciones cuerpo_funcion:cf
{:
	semanticErrorManager.semanticDebug("22"); 
    // Comprueba que existe al menos una sentencia return y que todas son del mismo tipo que el retorno de la funcion
    List<TypeIF> listaSentenciasReturn = cf.getListaSentenciasReturn();
    if (listaSentenciasReturn == null || listaSentenciasReturn.size() == 0) {
        semanticErrorManager.semanticFatalError("ERROR: la funcion " + idFuncion.getLexema()
            +" debe proporcionar alguna sentencia RETURN"); 
    } else {
        TypeFunction function = (TypeFunction)scopeManager.searchType(idFuncion.getLexema().toUpperCase());
        TypeIF tipoResultado = function.getTipoResultado();
        for (TypeIF s:listaSentenciasReturn) {
            if (!s.equals(tipoResultado)) {
                semanticErrorManager.semanticFatalError("ERROR: Tipo erroneo en return en la funcion " + idFuncion.getLexema()
                    +" linea: " + idFuncion.getLine()); 
            }
        }
    }
    
    // Comprueba que el identificador de apertura de la funcion coincide con el de cierre
    String idCierre = cf.getNombreFuncion().toUpperCase();
	semanticErrorManager.semanticInfo("Comprueba el id de cierre"); 
    if (!idCierre.equalsIgnoreCase(idFuncion.getLexema())) {
        semanticErrorManager.semanticFatalError("ERROR: El identificador de apertura debe coincidir con el de cierre, apertura: " + idFuncion.getLexema()
                    +", cierre: " + idCierre); 
    } 
    
	DeclaracionSubprograma declaracionFuncion = new DeclaracionSubprograma(idFuncion.getLexema(), declaraciones, cf);
	declaracionFuncion.generarCodigoIntermedio();
    
    scopeManager.closeScope();
	RESULT = declaracionFuncion;
:};

       
procedimiento ::= PROCEDURE IDENTIFICADOR:idProcedimiento ABRE_PARENTESIS parametros_subprograma:listaParametros CIERRA_PARENTESIS
{:
  semanticErrorManager.semanticDebug("23");
    // El procedimiento es igual que la funcion, pero crea un tipo procedure que no tiene retorno
    String nombreProcedimiento = idProcedimiento.getLexema().toUpperCase();
        
    // Comprueba si la funcion ha sido declarada
    if (!(scopeManager.containsSymbol(nombreProcedimiento)
        && scopeManager.containsType(nombreProcedimiento))) {
        //    semanticErrorManager.semanticInfo("Declaracion de procedimiento " + nombreProcedimiento 
        //                                    + " en linea " + idProcedimiento.getLine());
            
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF tablaTipos = scope.getTypeTable();
        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
        //Creo un tipo y un simbolo para el procedimiento y los añado a la tabla
        //    semanticErrorManager.semanticInfo("Crea un tipo para " + nombreProcedimiento);
        TypeProcedure tipoProcedimiento = new TypeProcedure(scope, nombreProcedimiento);
            
        tablaTipos.addType(nombreProcedimiento, tipoProcedimiento);
        //    semanticErrorManager.semanticInfo("Lo añade a la tabla de tipos ");
        //    semanticErrorManager.semanticInfo(tablaTipos);
        SymbolProcedure simboloProcedimiento = new SymbolProcedure(scope, nombreProcedimiento, tipoProcedimiento);
        tablaSimbolos.addSymbol(nombreProcedimiento, simboloProcedimiento);
            
        // Abro un nuevo ambito para el procedimiento, con una nueva tabla simbolos y tipos
        //    semanticErrorManager.semanticInfo("Nuevo ambito " + nombreProcedimiento);
        ScopeIF scopeProcedimiento = scopeManager.openScope(nombreProcedimiento);
        TypeTableIF tablaTiposProcedimiento = scopeProcedimiento.getTypeTable();
        SymbolTableIF tablaSimbolosProcedimiento = scopeProcedimiento.getSymbolTable();
            
        semanticErrorManager.semanticInfo("Procesa los parametros " + listaParametros);
        // Almaceno los parametros en la tabla de simbolos y la de tipos
        for (SymbolParameter parametro:listaParametros.getListaParametros()) {
            semanticErrorManager.semanticInfo("Declaracion de parametro " + parametro.getName() 
                                + " de tipo " + parametro.getType().getName());
            tablaSimbolosProcedimiento.addSymbol(parametro.getName().toUpperCase(),parametro);
            tipoProcedimiento.addTipoParametro(parametro.getType());
        }
    } else {
        semanticErrorManager.semanticFatalError("ERROR: Procedimiento ya declarada " + nombreProcedimiento
                                                    +" en linea: "+idProcedimiento.getLine());        
    }
        
:}  IS declaraciones:declaraciones cuerpo:cp
{:
	semanticErrorManager.semanticDebug("24");
    // Comprueba que el identificador que cierra el cuerpo del procedimiento es equivalente al de apertura
    String idCierre = cp.getIdProcedimiento().toUpperCase();
    //    semanticErrorManager.semanticInfo("Cierre procedimiento " + idCierre);
    if (!idProcedimiento.getLexema().equalsIgnoreCase(idCierre)) {
        semanticErrorManager.semanticFatalError("ERROR: el identificador de apertura debe coincidir con el de cierre, apertura: " + idProcedimiento.getLexema()
                                                    +" . Cierre: "+idCierre);       
    }
    //    semanticErrorManager.semanticDebug("Cierro ambito " + idCierre);
	DeclaracionSubprograma declaracionProcedimiento = new DeclaracionSubprograma(idProcedimiento.getLexema(), declaraciones, cp);
	declaracionProcedimiento.generarCodigoIntermedio();
    
    scopeManager.closeScope();
	RESULT = declaracionProcedimiento;
:};
    
parametros_subprograma ::= lista_nombres:listaNombres DOS_PUNTOS tipo:tipo PUNTO_COMA parametros_subprograma:listaParametrosPrevios
{:
semanticErrorManager.semanticDebug("25");
    ScopeIF scope = scopeManager.getCurrentScope();
	TypeTableIF tablaTipos = scope.getTypeTable();
	SymbolTableIF tablaSimbolos = scope.getSymbolTable();
    //    semanticErrorManager.semanticInfo("Comienza a procesar la lista de parametros");
    //    semanticErrorManager.semanticInfo("Tipo de los parametros: " + tipo);
    		
	if (!scopeManager.containsType((String)tipo)) {
	   semanticErrorManager.semanticFatalError("ERROR: tipo desconocido " + (String)tipo);
	} else {
	   //    semanticErrorManager.semanticInfo("Tipo reconocido");
	   //    semanticErrorManager.semanticInfo("Parametros previos " + listaParametrosPrevios);
        ListaParametrosDeclaracion listaParametros = new ListaParametrosDeclaracion(((ListaParametrosDeclaracion)listaParametrosPrevios).getListaParametros());
        // Para cada nombre creo un parametro
		for (Object objeto:((ListaObjetos)listaNombres).getVariables()) {
		       String nombreParametro = (String)objeto;
		       //    semanticErrorManager.semanticInfo("Declaracion de parametro " + nombreParametro + " tipo " + (String)tipo);
		       if (scopeManager.containsSymbol(nombreParametro)) {
		           semanticErrorManager.semanticFatalError("ERROR: parametro duplicado " + nombreParametro);
	           } else {
	               //    semanticErrorManager.semanticDebug("Parametro valida, crea el simbolo");
	               SymbolParameter sP = new SymbolParameter(scope, nombreParametro, tablaTipos.getType((String)tipo));
	               tablaSimbolos.addSymbol(nombreParametro, sP);
	               listaParametros.getListaParametros().add(sP);
	           }
	        }
	        RESULT = listaParametros;
	    }	    
	    :}
        | lista_nombres:listaNombres DOS_PUNTOS tipo:tipo 
        {:
        semanticErrorManager.semanticDebug("26");
            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
            if (!scopeManager.containsType((String)tipo)) {
                semanticErrorManager.semanticFatalError("ERROR: tipo desconocido " + (String)tipo);
            } else {
	            ListaParametrosDeclaracion listaParametros = new ListaParametrosDeclaracion();
	            // Para cada nombre creo un parametro
	            for (Object objeto:((ListaObjetos)listaNombres).getVariables()) {
	               String nombreParametro = (String)objeto;
	                //    semanticErrorManager.semanticInfo("Declaracion de parametro " + nombreParametro);
	                if (scopeManager.containsSymbol(nombreParametro)) {
	                   semanticErrorManager.semanticFatalError("ERROR: parametro duplicado " + nombreParametro);
	                } else {
	                   //    semanticErrorManager.semanticDebug("Parametro valida, crea el simbolo");
	                   SymbolParameter sP = new SymbolParameter(scope, nombreParametro, scopeManager.searchType((String)tipo));
	                   tablaSimbolos.addSymbol(nombreParametro, sP);
	                   listaParametros.getListaParametros().add(sP);
	                }
	            }
	            RESULT = listaParametros;
            }        
        :}
        | vacio;
 

cuerpo_funcion::= BEGIN lista_sentencias_funcion:listaSentenciasReturn END IDENTIFICADOR:idFuncion PUNTO_COMA
{:
	semanticErrorManager.semanticDebug("27");
    CuerpoFuncion cf = new CuerpoFuncion();
	if (listaSentenciasReturn == null) {
        listaSentenciasReturn = new ListaSentenciasReturn();
		semanticErrorManager.semanticInfo("Inicializa listaSentenciasReturn" + listaSentenciasReturn);        
    }
    cf.setListaSentenciasReturn(listaSentenciasReturn.getListaTiposReturn());
    cf.setNombreFuncion(idFuncion.getLexema());
    RESULT = cf;
:};

lista_sentencias_funcion ::=  sentencia_funcion:posibleReturn PUNTO_COMA lista_sentencias_funcion:listaReturns
{:
semanticErrorManager.semanticDebug("28");
    if (listaReturns == null) {
		semanticErrorManager.semanticInfo("Inicializa listaReturn" + listaReturns);        
        listaReturns = new ListaSentenciasReturn();
    }
    if (posibleReturn != null) {
        listaReturns.addReturnType(posibleReturn.getType());
        semanticErrorManager.semanticInfo("Añade return a la list " + posibleReturn.getType().getName());        
    }
    RESULT = listaReturns;
:} |  vacio
{:
	semanticErrorManager.semanticDebug("29");
    RESULT = new ListaSentenciasReturn();
:};

sentencia_funcion ::= sentencia 
    | sentencia_return:sent_return
{:
semanticErrorManager.semanticDebug("30");
    RESULT = sent_return;
:};

sentencia_return ::= RETURN expresion:e
{:
semanticErrorManager.semanticDebug("31");
    //    semanticErrorManager.semanticInfo("Encontrada sentencia return de tipo " + e.getType().getName());
    RESULT = e;
:};



cuerpo ::=  BEGIN lista_sentencias:listaSentencias END IDENTIFICADOR:idProcedimiento PUNTO_COMA
    {:
		semanticErrorManager.semanticDebug("32 : CUERPO");
        semanticErrorManager.semanticInfo("Cierre procedimiento " + idProcedimiento.getLexema());
        Cuerpo cuerpo = new Cuerpo();
        cuerpo.setIdProcedimiento(idProcedimiento.getLexema().toUpperCase());
        if (listaSentencias != null) {
			semanticErrorManager.semanticInfo("listaSentencias.getIntermediateCode()");
            cuerpo.setIntermediateCode(listaSentencias.getIntermediateCode());			
        }
        
        semanticErrorManager.semanticInfo("Codigo de procedimiento: " + idProcedimiento.getLexema() + cuerpo.getIntermediateCode());
        RESULT = cuerpo;
    :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en cuerpo de procedimiento."); :};
 


        
/*******************************************************************************
    CAMBIO: TRUE,FALSE pasan a valor_booleano
    NUMERO pasa a valor_numerico
*******************************************************************************/
expresion ::= expresion:exp1 PLUS:operador expresion:exp2
    {:
    semanticErrorManager.semanticDebug("33");
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        
        // semanticErrorManager.semanticdebug("Expresion SUMA " + type1.getName() + " + " + type2.getName());
        
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = type1;   // No hay conversion de tipos
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
            //    semanticErrorManager.semanticDebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
                        
            expresionResultado.generarCodigoIntermedio(e1, e2, operador.getLexema());
            semanticErrorManager.semanticDebug("Codigo expresion suma: " + expresionResultado.getIntermediateCode());
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}
        | expresion:exp1 MAYOR:operador expresion:exp2
    {:
    semanticErrorManager.semanticDebug("34");
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        // semanticErrorManager.semanticdebug("Expresion " + type1.getName() + " > " + type2.getName());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = scopeManager.searchType(TypeSimple.LOGICO);
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
            // semanticErrorManager.semanticdebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            
            expresionResultado.generarCodigoIntermedio(e1,e2,operador.getLexema());
            semanticErrorManager.semanticDebug("Codigo expresion MAYOR QUE: " + expresionResultado.getIntermediateCode());
            
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}            
        | expresion:exp1 IGUAL:operador expresion:exp2
    {:
    semanticErrorManager.semanticDebug("35");
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        // semanticErrorManager.semanticdebug("Expresion " + type1.getName() + " == " + type2.getName());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = scopeManager.searchType(TypeSimple.LOGICO);
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
            // semanticErrorManager.semanticdebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            
            expresionResultado.generarCodigoIntermedio(e1,e2,operador.getLexema());
            semanticErrorManager.semanticDebug("Codigo expresion IGUALDAD: " + expresionResultado.getIntermediateCode());
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}         
        | expresion:exp1 OR:operador expresion:exp2 
    {:
    semanticErrorManager.semanticDebug("36");
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        // semanticErrorManager.semanticdebug("Expresion " + type1.getName() + " OR " + type2.getName());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = scopeManager.searchType(TypeSimple.LOGICO);
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
            // semanticErrorManager.semanticdebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            
            expresionResultado.generarCodigoIntermedio(e1,e2,operador.getLexema());
            semanticErrorManager.semanticDebug("Codigo expresion OR: " + expresionResultado.getIntermediateCode());
            
            RESULT = expresionResultado;
        } else { 
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
            
        }
    :}            
        | ABRE_PARENTESIS:a expresion:exp CIERRA_PARENTESIS:b
{:
semanticErrorManager.semanticDebug("37 : expresion ::= ABRE_PARENTESIS:a expresion:exp CIERRA_PARENTESIS:b");
    RESULT = exp;
:}        
        | llamada_subprograma:l
{:  
    semanticErrorManager.semanticDebug("38: expresion ::= llamada_subprograma:l");
    if (l != null && l.getType() != null) {
        // Si existe devolucion es que es una funcion y no un procedimiento
        Expresion expresionResultado = new Expresion(l.getType(), l.getLexema());
        expresionResultado.generarCodigoIntermedio(l);

        RESULT = expresionResultado;
    } else {
       semanticErrorManager.semanticFatalError("ERROR: uso de un procedimiento en una expresion "); 
    }
:}        
        | referencia:r
{:
semanticErrorManager.semanticDebug("39: expresion ::= referencia:r");
    TypeIF tipo = r.getType();
    String lexema = r.getLexema().toUpperCase();
    Expresion expresion = new Expresion(tipo, lexema);
    semanticErrorManager.semanticDebug("Creo el objeto expresion " + expresion);
    expresion.generarCodigoIntermedio(r);
    
    semanticErrorManager.semanticDebug("Expresion referencia: " + expresion.getIntermediateCode());
    RESULT = expresion;
:}              
        | valor:valor
{:
    semanticErrorManager.semanticDebug("40: expresion ::= valor:valor");
    Expresion expresion = new Expresion(valor.getType(), valor.getLexema().toUpperCase());
    expresion.generarCodigoIntermedio(valor);
    semanticErrorManager.semanticDebug("Expresion valor: " + expresion.getIntermediateCode());
    RESULT = expresion;
:};

referencia ::= IDENTIFICADOR:id 
{:
	semanticErrorManager.semanticDebug("41: referencia ::= IDENTIFICADOR:id");
    String name = id.getLexema().toUpperCase();
    if (scopeManager.containsSymbol(name)) {
        SymbolIF simbolo = scopeManager.searchSymbol(name);
		semanticErrorManager.semanticInfo("Simbolo " + name + " " + simbolo);
        TypeIF tipo = simbolo.getType();
        Referencia r = new Referencia(tipo, name, id.getLine()); 
		semanticErrorManager.semanticDebug("Objeto referencia creado");
        r.generarCodigoIntermedio();
        semanticErrorManager.semanticDebug("Codigo referencia generado: " + r.getIntermediateCode());
        RESULT = r;
    } else {
       semanticErrorManager.semanticFatalError("ERROR: uso de una referencia desconocida " + id.getLine() + " " + name);         
    }
:}
        | acceso_registro:a
{:
semanticErrorManager.semanticDebug("42: referencia ::= acceso_registro:a");
    RESULT = a;
:};

acceso_registro ::= referencia:registro ACCESO IDENTIFICADOR:campo
{:
	semanticErrorManager.semanticDebug("43 acceso_registro ::= referencia:registro ACCESO IDENTIFICADOR:");
    String nombreRegistro = registro.getLexema().toUpperCase();
    String nombreCampo = campo.getLexema().toUpperCase();
    TypeIF tipoRegistro = registro.getType();
    if (tipoRegistro instanceof TypeRecord) {
        TypeRecord tRec = (TypeRecord)tipoRegistro;
        if (tRec.containsCampo(nombreCampo)) {
            TypeIF innerType = tRec.getCampo(nombreCampo).getType();
            Referencia r = new Referencia(innerType, nombreRegistro + "." + nombreCampo, campo.getLine());
			r.setAccesoRegistro(true);
			SymbolVariable variableRegistro = (SymbolVariable)scopeManager.searchSymbol(nombreRegistro);
			r.setVariableRegistro(variableRegistro);
			
			SymbolVariable campoRegistro = new SymbolVariable(variableRegistro.getScope(), nombreCampo, innerType);
			r.setCampoRegistro(campoRegistro);
			
            r.generarCodigoIntermedio(registro, nombreCampo);
            semanticErrorManager.semanticDebug("Codigo acceso registro: " + r.getIntermediateCode());
             
            RESULT = r;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: campo no declarado " + nombreCampo);
        }
    } else {
        semanticErrorManager.semanticFatalError("ERROR: tipo no declarado " + tipoRegistro.getName());
    }
:};

       
lista_sentencias ::=  sentencia:sentencia PUNTO_COMA lista_sentencias:listaSentencias 
    {:
		semanticErrorManager.semanticDebug("44: LISTA_SENTENCIAS");
        if (listaSentencias == null) {
            listaSentencias = new ListaSentencias();
        }
        listaSentencias.addSentencia((NonTerminal)sentencia);
        listaSentencias.generarCodigoIntermedio();
        semanticErrorManager.semanticDebug("Codigo lista Sentencias: " + listaSentencias.getIntermediateCode());   
        RESULT = listaSentencias;
    :}
        |  vacio {:
			semanticErrorManager.semanticDebug("45: LISTA_SENTENCIAS: VACIO");
        :};

sentencia ::= sentencia_entrada_salida:sentencia
{:
semanticErrorManager.semanticDebug("46");
    RESULT = sentencia;
:} 
        | sentencia_if:sentencia
{:
semanticErrorManager.semanticDebug("47");
    RESULT = sentencia;
:}
        | sentencia_for:sentencia
{:
semanticErrorManager.semanticDebug("48");
    RESULT = sentencia;
:}
        | sentencia_asignacion:sentencia
{:
semanticErrorManager.semanticDebug("49");
    RESULT = sentencia;
:}
        | llamada_subprograma:sentencia
{:
semanticErrorManager.semanticDebug("50");
    RESULT = sentencia;
:};

sentencia_if ::= IF expresion:objExp THEN lista_sentencias:listaSentencias END IF
{:
semanticErrorManager.semanticDebug("51");
    Expresion expCondicion = (Expresion)objExp;
    if (!expCondicion.getType().getName().equalsIgnoreCase(TypeSimple.LOGICO)) {
        semanticErrorManager.semanticFatalError("ERROR: la condicion debe devolver un tipo boolean" );
    }
    SentenciaIF s = new SentenciaIF();
    s.generarCodigoIntermedio(expCondicion, listaSentencias);
    semanticErrorManager.semanticDebug("Codigo IF: " + s.getIntermediateCode());
    RESULT = s;
:}
        | IF expresion:objExp THEN lista_sentencias:listaSentencias ELSE lista_sentencias:listaSentenciasElse END IF
{:
semanticErrorManager.semanticDebug("52");
    Expresion expCondicion = (Expresion)objExp;
    if (!expCondicion.getType().getName().equalsIgnoreCase(TypeSimple.LOGICO)) {
        semanticErrorManager.semanticFatalError("ERROR: la condicion debe devolver un tipo boolean" );
    }
    SentenciaIF s = new SentenciaIF();
    s.generarCodigoIntermedio(expCondicion, listaSentencias, listaSentenciasElse);
    semanticErrorManager.semanticDebug("Codigo IF-ELSE" + s.getIntermediateCode());
    RESULT = s;
:}        
        | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia if"); :};


sentencia_for ::=  FOR IDENTIFICADOR:indice IN expresion:expInicio 
    DELIMITADOR_RANGO expresion:expFin LOOP lista_sentencias:listaSentencias 
    END LOOP
{:
semanticErrorManager.semanticDebug("53");
    //Indice debe corresponder con una variable de tipo entero
    List<SymbolIF> posiblesIndices = scopeManager.searchSymbols(indice.getLexema().toUpperCase());
    if (posiblesIndices == null || posiblesIndices.size() == 0) {
        semanticErrorManager.semanticFatalError("ERROR: simbolo no declarado en indice, linea: " + indice.getLine());
    } else {
        // Compruebo que el tipo de la variable sea entero
        SymbolVariable varIndex = null;
        TypeIF tipoEntero = scopeManager.searchType(TypeSimple.NUMERO);
        for (SymbolIF posibleIndex:posiblesIndices) {
            if (posibleIndex.getType().equals(tipoEntero)) {
                varIndex = (SymbolVariable)posibleIndex;
            }
        }
        if (varIndex == null) {
            semanticErrorManager.semanticFatalError("ERROR: el indice debe ser una variable de tipo entero, linea: " + indice.getLine());
        } else {
            if (!expInicio.getType().equals(tipoEntero) || !expFin.getType().equals(tipoEntero)) {
                semanticErrorManager.semanticFatalError("ERROR: el rango de la sentencia for debe ser expresiones de tipo entero, linea: " + indice.getLine());
            }
        }
        SentenciaFor s = new SentenciaFor();
        s.generarCodigoIntermedio(varIndex, expInicio, expFin, listaSentencias);
        semanticErrorManager.semanticDebug("Codigo FOR: " + s.getIntermediateCode());        
        RESULT = s;
    }
:};      
        
sentencia_asignacion ::= referencia:referencia ASIGNACION expresion:expresion
{:
	semanticErrorManager.semanticDebug("54: sentencia_asignacion ::= referencia:referencia ASIGNACION expresion:expresion");
    
    // Debo comprobar que tanto referencia como expresion coinciden en tipo y que este es uno de los tipos simples
    if (!(referencia.getType() instanceof TypeSimple)) {
        semanticErrorManager.semanticFatalError("ERROR: no se permiten asignaciones a tipos compuestos, linea: " + referencia.getLine());
    } else if (!referencia.getType().equals(expresion.getType())) {
        semanticErrorManager.semanticFatalError("ERROR: tipos distintos en asignacion, linea: " + referencia.getLine()); 
    } else {
        // semanticErrorManager.semanticInfo("Asignacion valida");
        SentenciaAsignacion s = new SentenciaAsignacion();
        s.generarCodigoIntermedio(referencia, expresion);
        semanticErrorManager.semanticDebug("Codigo asignacion: " + s.getIntermediateCode());
        RESULT = s;
    }
:};

sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS expresion:parametro CIERRA_PARENTESIS
{:
	semanticErrorManager.semanticDebug("55: sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS expresion:parametro CIERRA_PARENTESIS");
    if (!(parametro.getType() instanceof TypeSimple)) {
        semanticErrorManager.semanticFatalError("ERROR: parametros no compatibles en put_line " + parametro.getLexema());
    }
    SentenciaPutLine sent = new SentenciaPutLine();
    sent.generarCodigoIntermedio(parametro);
    semanticErrorManager.semanticInfo(sent.getIntermediateCode());
    RESULT = sent;
:}
		| PUT_LINE ABRE_PARENTESIS CADENA:cadena CIERRA_PARENTESIS
{:
	semanticErrorManager.semanticDebug("55b: sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS CADENA:cadena CIERRA_PARENTESIS");
	SentenciaPutLine sent = new SentenciaPutLine();
    sent.generarCodigoIntermedio(cadena.getLexema());
	semanticErrorManager.semanticInfo(sent.getIntermediateCode());
    RESULT = sent;
:};

parametro ::= valor:valor
{:
	semanticErrorManager.semanticDebug("56: parametro ::= valor:valor");
    Parametro parametro =  new Parametro(valor.getType(), valor.getLexema().toUpperCase(), valor.getLine());
    RESULT = parametro;
:}
        | referencia:referencia
{:
semanticErrorManager.semanticDebug("57: referencia:referencia");
    Parametro parametro = new Parametro(referencia.getType(),referencia.getLexema().toUpperCase(),referencia.getLine());
    RESULT = parametro;
:};

llamada_subprograma ::= IDENTIFICADOR:id ABRE_PARENTESIS lista_parametros:pa CIERRA_PARENTESIS
{:
semanticErrorManager.semanticDebug("58: llamada_subprograma ::= IDENTIFICADOR:id ABRE_PARENTESIS lista_parametros:pa CIERRA_PARENTESIS");
    String name = id.getLexema().toUpperCase();
    if (!scopeManager.containsSymbol(name)) {
        semanticErrorManager.semanticFatalError("ERROR: subprograma desconocido " + name + ", linea: " + id.getLine());    
    } else {
        SymbolIF s = scopeManager.searchSymbol(name);
        if (s instanceof SymbolFunction) {
            // Se trata de una funcion
            SymbolFunction sf = (SymbolFunction)s;
            TypeFunction tf = (TypeFunction)sf.getType();
            
            List<TypeIF> paramInvocacion = pa.getParameterTypes();
            List<TypeIF> paramTeoricos = tf.getTipoParametros();
            if (paramInvocacion.equals(paramTeoricos)) {
                //OK
                TypeIF returnType = tf.getTipoResultado();
                
                LlamadaSubprograma funcion = new LlamadaSubprograma(returnType, name);
                funcion.generarCodigoIntermedio(sf, pa);
                RESULT = funcion;
            } else {
                semanticErrorManager.semanticFatalError("ERROR: parametros erroneos en invocacion a funcion " 
                    + name + ", linea: " + id.getLine());    
            }
        } else if (s instanceof SymbolProcedure) {
            // Se trata de un procedimiento
            // Se trata de una funcion
            SymbolProcedure sf = (SymbolProcedure)s;
            TypeProcedure tf = (TypeProcedure)sf.getType();
            
            List<TypeIF> paramInvocacion = pa.getParameterTypes();
            List<TypeIF> paramTeoricos = tf.getTipoParametros();
            if (!paramInvocacion.equals(paramTeoricos)) {
                semanticErrorManager.semanticFatalError("ERROR: parametros erroneos en invocacion a procedimiento " + name + ", linea: " + id.getLine());    
            }
            
            LlamadaSubprograma procedimiento = new LlamadaSubprograma();
            procedimiento.generarCodigoIntermedio(sf, pa);
            RESULT = procedimiento;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: El simbolo " + name 
                + " no se corresponde con un subprograma, linea: " + id.getLine());
        }
    }
:};

lista_parametros ::= expresion:e SEPARADOR_COMA lista_parametros:lista
{:
	semanticErrorManager.semanticDebug("59: lista_parametros ::= expresion:e SEPARADOR_COMA lista_parametros:lista");
    lista.addParameterType(e.getType());
	lista.addParametro(e);
    ScopeIF scope = scopeManager.getCurrentScope();
    IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
    cb.addQuadruples(lista.getIntermediateCode());
    cb.addQuadruples(e.getIntermediateCode());
    lista.setIntermediateCode(cb.create());
    RESULT = lista;
:}
        | expresion:e
{:
semanticErrorManager.semanticDebug("60: lista_parametros ::= expresion:e");
	ListaParametrosEjecucion lista = new ListaParametrosEjecucion();
	lista.addParameterType(e.getType());
	lista.addParametro(e);
    ScopeIF scope = scopeManager.getCurrentScope();
    IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
    cb.addQuadruples(e.getIntermediateCode());
    lista.setIntermediateCode(cb.create());
    RESULT = lista;
:}  
        | vacio
{:
semanticErrorManager.semanticDebug("61: lista_parametros ::= vacio");
    ListaParametrosEjecucion lista = new ListaParametrosEjecucion();
    RESULT = lista;
:};