package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;
import compiler.code.translator.*;

// Declaración del código de usuario

action code {:
    
    SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
    SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
    ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
    FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}  

parser code {:
    SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
    
    public void syntax_error(Symbol symbol)
    { 
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxError ("Error sintactico", token);     
    }
        
    public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
    {   
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxFatalError ("Error fatal", token);
    }
:}

// Declaración de terminales (Ejemplo)

// Palabras reservadas
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;

// OPERADORES
terminal Token PLUS;
terminal Token MAYOR;
terminal Token IGUAL;
terminal Token ASIGNACION;
terminal Token ACCESO;

// DELIMITADORES
terminal Token ABRE_PARENTESIS;
terminal Token CIERRA_PARENTESIS;
terminal Token DELIMITADOR_RANGO;
terminal Token SEPARADOR_COMA;
terminal Token PUNTO_COMA;
terminal Token DOS_PUNTOS;

// OTROS
terminal Token NUMERO;
terminal Token IDENTIFICADOR;
terminal Token CADENA;

// Declaración de no terminales
// no modificar los propuestos

non terminal            program;
non terminal Axiom      axiom;

non terminal    vacio;
non terminal    cabecera;
non terminal    Declaraciones declaraciones;
non terminal    Declaraciones declaracion_constantes;
non terminal    Declaraciones declaracion_registros;
non terminal    Declaraciones declaracion_variables;
non terminal    Declaraciones declaracion_subprogramas;
non terminal    lista_nombres;
non terminal    Declaraciones constante;
non terminal    Valor   valor;

non terminal    registro;
non terminal    ListaObjetos lista_campos;
non terminal    tipo;

non terminal    Declaraciones variable;
non terminal    Cuerpo cuerpo;
non terminal    ListaSentencias lista_sentencias;
non terminal    sentencia;
non terminal    SentenciaPutLine sentencia_entrada_salida;
non terminal    SentenciaAsignacion sentencia_asignacion;
non terminal    sentencia_if;
non terminal    sentencia_for;
non terminal    Referencia referencia;
non terminal    Referencia acceso_registro;
non terminal    Expresion expresion;
non terminal    Parametro parametro;
non terminal    LlamadaSubprograma llamada_subprograma;
non terminal    ListaParametrosEjecucion lista_parametros;
non terminal    DeclaracionSubprograma subprograma;
non terminal    DeclaracionSubprograma funcion;
non terminal    DeclaracionSubprograma procedimiento;
non terminal    ListaParametrosDeclaracion parametros_subprograma;
non terminal    tipo_primitivo;
non terminal    CuerpoFuncion cuerpo_funcion;
non terminal    ListaSentenciasReturn lista_sentencias_funcion;
non terminal    sentencia_funcion;
non terminal    SentenciaReturn sentencia_return;

// Declaración de relaciones de precedencia, SEPARADOS POR COMAS

precedence left OR;
precedence left IGUAL;
precedence left MAYOR;
precedence left PLUS;
precedence left ACCESO, ABRE_PARENTESIS, CIERRA_PARENTESIS;

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {:
        List<ScopeIF> scopes = scopeManager.getAllScopes();
        semanticErrorManager.semanticDebug("Numero de entornos: " + scopes.size());
		MemoryUtil.asignarDirecciones();
		
        ScopeIF scopeActual = null;
        for (ScopeIF scope:scopes) {
			if (scope.getLevel() == 0) {
				scopeActual = scope;
			}
		}
        
        IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeActual);
        cb.addQuadruple("INICIO", null,MemoryUtil.getgAddress(), ax.getLabel());
        
        List intermediateCode = ax.getIntermediateCode();
        cb.addQuadruples(intermediateCode);
		cb.addQuadruple (InstructionSet.FINAL);
        syntaxErrorManager.syntaxInfo ("Codigo intermedio generado " + cb.create());

        ExecutionEnvironmentEns2001 e = new ExecutionEnvironmentEns2001();
        finalCodeFactory.setEnvironment(e); 
          
        finalCodeFactory.create(cb.create());               
        
        syntaxErrorManager.syntaxInfo ("Codigo intermedio generado  " + cb.create());
        syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= cabecera:apertura declaraciones:declaraciones cuerpo:cierre
{:
    semanticErrorManager.semanticDebug("1 axiom ::= cabecera:apertura declaraciones cuerpo:cierre");
    String idApertura = (String)apertura;
    String idCierre = cierre.getIdProcedimiento();
    if (!idApertura.equalsIgnoreCase(idCierre)) {
        semanticErrorManager.semanticFatalError("ERROR semantico: el identificador de apertura debe ser el mismo que el de cierre: "
            + idApertura + " " + idCierre);
    }
    
    Axiom ax = new Axiom();
	LabelFactoryIF labelFactory = new LabelFactory ();
    LabelIF label = labelFactory.create (idApertura);
	ax.setLabel(label);
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	if(declaraciones != null) {
		ax.getIntermediateCode().addAll(declaraciones.getIntermediateCode());
    }            
    cb.addQuadruple(InstructionSet.LABEL, label, 0);
    ax.getIntermediateCode().addAll(cb.create());
    ax.getIntermediateCode().addAll(cierre.getIntermediateCode());
	scopeManager.closeScope();
    RESULT = ax;
:}
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

vacio ::= {:
    syntaxErrorManager.syntaxDebug ("2: VACIO");
:};

cabecera ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS CIERRA_PARENTESIS IS
    {:
		semanticErrorManager.semanticDebug("3: CABECERA");
        //Crear el ámbito global del programa asociado al nombre del procedimiento.
        String name = id.getLexema();
        scopeManager.openScope(name);

        ScopeIF scope = null;
		try {
			scope = scopeManager.getCurrentScope();
		} catch (Exception e) {
			semanticErrorManager.semanticError("Error en 3: CABECERA");
			semanticErrorManager.semanticError(e.getMessage());
		}
        
        //******************* Ahora insertar tipos basicos en la tabla
		
        TypeTableIF tablaTipos = scope.getTypeTable();
        TypeSimple tipoBooleano = new TypeSimple(scope);
        tipoBooleano.setName(TypeSimple.LOGICO);
        tablaTipos.addType(tipoBooleano);
        TypeSimple tipoEntero = new TypeSimple(scope);
        tipoEntero.setName(TypeSimple.NUMERO);
        tablaTipos.addType(tipoEntero);
        TypeSimple tipoString = new TypeSimple(scope);
        tipoString.setName(TypeSimple.CADENA);
        tablaTipos.addType(tipoString);
        RESULT = name;        
    :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de cabecera."); :};

tipo ::= IDENTIFICADOR:id  
{:
    RESULT=id.getLexema();
:}
        | INTEGER:t 
{:
    RESULT=TypeSimple.NUMERO; 
:} 
        | BOOLEAN:t 
{:
    RESULT=TypeSimple.LOGICO; 
:};

tipo_primitivo ::= INTEGER:t 
{: 
    RESULT=TypeSimple.NUMERO; 
:} 
        | BOOLEAN:t 
{: 
    RESULT=TypeSimple.LOGICO; 
:};
        
valor ::= NUMERO:n
{:
    Valor v = new Valor(scopeManager.searchType(TypeSimple.NUMERO), n.getLexema(), n.getLine(), new Value(Integer.parseInt(n.getLexema())));
    RESULT =v; 
:}
        | TRUE:t 
{:
    Valor v = new Valor(scopeManager.searchType(TypeSimple.LOGICO), t.getLexema(), t.getLine(), new Value(Boolean.TRUE));
    RESULT =v; 
:}
        | FALSE:f 
{:
    Valor v = new Valor(scopeManager.searchType(TypeSimple.LOGICO), f.getLexema(), f.getLine(), new Value(Boolean.FALSE));
    RESULT =v; 
:}
        | CADENA:c 
{:
    Valor v = new Valor(scopeManager.searchType(TypeSimple.CADENA), c.getLexema(), c.getLine(), new Value(c.getLexema()));
    RESULT =v; 
:};             

declaraciones ::= declaracion_constantes:dc
{:
	semanticErrorManager.semanticDebug("declaraciones ::= declaracion_constantes " + dc);
	RESULT =dc;
:};

declaracion_constantes ::= constante:c declaracion_constantes:declaraciones 
{:
	semanticErrorManager.semanticDebug("declaracion_constantes ::= constante declaracion_constantes ");
	RESULT=declaraciones.addDeclaracion(c);
:}
        | declaracion_registros:dr
{:
	semanticErrorManager.semanticDebug("declaracion_constantes ::= declaracion_registros");
	RESULT = dr;
:};


constante ::= lista_nombres:listaNombres DOS_PUNTOS CONSTANT ASIGNACION valor:v PUNTO_COMA
    {:
        semanticErrorManager.semanticDebug("constante ::= lista_nombres:listaNombres DOS_PUNTOS CONSTANT ASIGNACION valor:v PUNTO_COMA");
        ScopeIF scope = scopeManager.getCurrentScope();
        String nombreConstante = (String)((ListaObjetos)listaNombres).get(0);

        // comprueba si la constante ha sido declarada y se encuentra en la tabla de simbolos
        if (scope.getSymbolTable().containsSymbol(nombreConstante)) {
            semanticErrorManager.semanticFatalError("Error: la constante "+nombreConstante+" ya ha sido declarada");
        } else {
            // Creo la constante en el ambito
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            SymbolConstant simboloCte = new SymbolConstant(scope,nombreConstante.toUpperCase(),v.getType());
			simboloCte.setValue(v.getValue());
			
            // La guardo en la tabla de simbolos
            tablaSimbolos.addSymbol(nombreConstante, simboloCte);
            Declaraciones dc = new Declaraciones();
			RESULT = dc;
        }
    :};
    
lista_nombres ::= IDENTIFICADOR:id SEPARADOR_COMA lista_nombres:listaNombres
    {:
		semanticErrorManager.semanticDebug("lista_nombres ::= IDENTIFICADOR:id SEPARADOR_COMA lista_nombres:listaNombres");
        ListaObjetos listaResultado = new ListaObjetos((ListaObjetos)listaNombres);
        listaResultado.add(id.getLexema().toUpperCase());
        RESULT = listaResultado;
    :}
    | IDENTIFICADOR:id
    {:
		semanticErrorManager.semanticDebug("15: Lista_nombres ::= identificador");
        ListaObjetos listaNombres = new ListaObjetos();
        listaNombres.add(id.getLexema().toUpperCase());
        RESULT = listaNombres;
    :};

declaracion_registros ::= registro declaracion_registros:dr 
{:
	semanticErrorManager.semanticDebug("declaracion_registros ::= registro declaracion_registros");
	RESULT = dr;
:}
        | declaracion_variables:dv
{:
	semanticErrorManager.semanticDebug("declaracion_registros ::= declaracion_variables");
	RESULT = dv;
:};
        
registro ::= TYPE IDENTIFICADOR:idRegistro IS RECORD lista_campos:listaCamposRegistro END RECORD PUNTO_COMA
    {:
        // Comprueba en la tabla de tipos si el tipo ya está declarado
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF typeTable = scope.getTypeTable();
        
        if (typeTable.containsType(idRegistro.getLexema().toUpperCase())) {
            semanticErrorManager.semanticFatalError("Error: el tipo "+idRegistro.getLexema()+" en la linea: "+idRegistro.getLine()+" ya ha sido declarado");
        } else {
            // Crea un tipo registro y lo almacena en la tabla de tipos
            TypeRecord tipoRegistro = new TypeRecord(scope, idRegistro.getLexema().toUpperCase());
            typeTable.addType(tipoRegistro);

            // Compruebo los campos
            for (int i = 0; i<listaCamposRegistro.size();i++) {
                CampoRegistro c = (CampoRegistro) listaCamposRegistro.get(i);
                SymbolVariable var = (SymbolVariable) c.getSymbol();
                if (!tipoRegistro.containsCampo(c.getNombre().toUpperCase())) {
                    tipoRegistro.addCampo(c.getNombre().toUpperCase(), var);                                       
                } else {
                    semanticErrorManager.semanticFatalError ("El campo: " + c.getNombre() +" en " + c.getLinea() + " ya ha sido definido.");
                }
            } 
        }
        
        
    :};

lista_campos ::= IDENTIFICADOR:idCampo DOS_PUNTOS tipo:tipoCampo PUNTO_COMA lista_campos:listaCampos
{:
    // Añadir ID + tipo a lista de campos del registro registro
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF tablaTipos = scope.getTypeTable();
    SymbolIF simbolo = new SymbolVariable(scope,
                                            idCampo.getLexema().toUpperCase(),
                                            scopeManager.searchType(tipoCampo.toString().toUpperCase()));
    CampoRegistro campo = new CampoRegistro(idCampo.getLexema().toUpperCase(), idCampo.getLine(), 
                                            idCampo.getColumn(), simbolo);
  
    if (listaCampos == null) {
        listaCampos = new ListaObjetos();
    }
    listaCampos.add(campo);    
    RESULT = listaCampos;
:} 
    | vacio;
   

declaracion_variables ::= variable:v declaracion_variables:declaraciones
{:
	RESULT=declaraciones.addDeclaracion(v);
:}
        | declaracion_subprogramas:declaracionSubprogramas
{:
	RESULT=declaracionSubprogramas;
:};

variable ::= lista_nombres:objListaNombres DOS_PUNTOS tipo:objTipo PUNTO_COMA
{:
    // Se declara una serie de variables
    String tipoVariable = ((String)objTipo).toUpperCase();
    ListaObjetos listaNombres = (ListaObjetos)objListaNombres; 
        
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF tablaTipos = scope.getTypeTable();
    SymbolTableIF tablaSimbolos = scope.getSymbolTable();
        
    // Si el tipo no existe, error
    if (!scopeManager.containsType(tipoVariable)) {
        semanticErrorManager.semanticFatalError("ERROR: El tipo " 
                                + tipoVariable + 
                                " no ha sido definido en el programa");
    } else {
        // Encontrado el tipo, valida que no haya nombres duplicados");
	    // Para cada nombre creo una variable
	    for (Object objeto:listaNombres.getVariables()) {
            String nombreVar = ((String)objeto).toUpperCase();
            if (tablaSimbolos.containsSymbol(nombreVar)) {
                semanticErrorManager.semanticFatalError("ERROR: variable duplicada " + nombreVar);
            } else {
	           semanticErrorManager.semanticDebug("Variable valida, crea el simbolo " + nombreVar + " de tipo " + tipoVariable);
	           SymbolVariable sV = new SymbolVariable(scope, nombreVar, scopeManager.searchType(tipoVariable));
	           tablaSimbolos.addSymbol(nombreVar, sV);
            }
        }
    }
:};


declaracion_subprogramas ::= subprograma:s declaracion_subprogramas:ds
{:
    if (ds == null) {
        ds = new Declaraciones();
    }
	RESULT = ds.addDeclaracionSubprograma(s);
:} 
        | vacio;
        
subprograma ::= funcion:f
{:
	RESULT = f;
:}	
    | procedimiento:p
{:
	RESULT = p;
:}	; 

funcion ::= FUNCTION IDENTIFICADOR:idFuncion ABRE_PARENTESIS parametros_subprograma:listaParametros CIERRA_PARENTESIS RETURN tipo_primitivo:tipoRetorno
{:
    String nombreFuncion = (idFuncion.getLexema()).toUpperCase();
    semanticErrorManager.semanticDebug("Declaracion de la funcion" + nombreFuncion);      
    
    // Comprueba si la funcion ha sido declarada
    if (!(scopeManager.containsSymbol(nombreFuncion)
            && scopeManager.containsType(nombreFuncion))) {            
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF tablaTipos = scope.getTypeTable();
        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
        //Creo un tipo y un simbolo para la funcion y los añado a la tabla
        TypeFunction tipoFuncion = new TypeFunction(scope, nombreFuncion.toUpperCase());
		TypeIF tipoResultado = scopeManager.searchType(((String)tipoRetorno).toUpperCase());
        tipoFuncion.setTipoResultado(tipoResultado);
        tablaTipos.addType(nombreFuncion, tipoFuncion);
        
		// Guarda el símbolo de la funcion
        SymbolFunction simboloFuncion = new SymbolFunction(scope, nombreFuncion, tipoFuncion);
        tablaSimbolos.addSymbol(nombreFuncion, simboloFuncion);
            
        // Abro un nuevo ambito para la funcion, con una nueva tabla simbolos y tipos
        semanticErrorManager.semanticInfo("Nuevo ambito " + nombreFuncion);
        ScopeIF scopeFuncion = scopeManager.openScope(nombreFuncion);
        
        TypeTableIF tablaTiposFuncion = scopeFuncion.getTypeTable();
        SymbolTableIF tablaSimbolosFuncion = scopeFuncion.getSymbolTable();
        
        // Almacena los parámetros en la propia funcion
        for (SymbolParameter parametro:listaParametros.getListaParametros()) {
            tablaSimbolosFuncion.addSymbol(parametro.getName().toUpperCase(),parametro);
            tipoFuncion.addTipoParametro(parametro.getType());
			tipoFuncion.addParametro(parametro);
        }
    } else {
        semanticErrorManager.semanticFatalError("ERROR: Funcion ya declarada " +  idFuncion.getLexema()
            +" en linea: "+idFuncion.getLine());        
    }
        
:} IS declaraciones:declaraciones cuerpo_funcion:cf
{:
    // Comprueba que existe al menos una sentencia return y que todas son del mismo tipo que el retorno de la funcion
    List<TypeIF> listaTiposReturn = cf.getListaTiposReturn();
    if (listaTiposReturn == null || listaTiposReturn.size() == 0) {
        semanticErrorManager.semanticFatalError("ERROR: la funcion " + idFuncion.getLexema()
            +" debe proporcionar alguna sentencia RETURN"); 
    } else {
        TypeFunction function = (TypeFunction)scopeManager.searchType(idFuncion.getLexema().toUpperCase());
        TypeIF tipoResultado = function.getTipoResultado();
        for (TypeIF s:listaTiposReturn) {
            if (!s.equals(tipoResultado)) {
                semanticErrorManager.semanticFatalError("ERROR: Tipo erroneo en return en la funcion " + idFuncion.getLexema()
                    +" linea: " + idFuncion.getLine()); 
            }
        }
    }
    
    // Comprueba que el identificador de apertura de la funcion coincide con el de cierre
    String idCierre = cf.getNombreFuncion().toUpperCase();
	semanticErrorManager.semanticInfo("Comprueba el id de cierre"); 
    if (!idCierre.equalsIgnoreCase(idFuncion.getLexema())) {
        semanticErrorManager.semanticFatalError("ERROR: El identificador de apertura debe coincidir con el de cierre, apertura: " + idFuncion.getLexema()
                    +", cierre: " + idCierre); 
    } 
    
	DeclaracionSubprograma declaracionFuncion = new DeclaracionSubprograma(idFuncion.getLexema(), declaraciones, cf);
	declaracionFuncion.generarCodigoIntermedio();
    
    scopeManager.closeScope();
	RESULT = declaracionFuncion;
:};

       
procedimiento ::= PROCEDURE IDENTIFICADOR:idProcedimiento ABRE_PARENTESIS parametros_subprograma:listaParametros CIERRA_PARENTESIS
{:
    // El procedimiento es igual que la funcion, pero crea un tipo procedure que no tiene retorno
    String nombreProcedimiento = idProcedimiento.getLexema().toUpperCase();
        
    // Comprueba si la funcion ha sido declarada
    if (!(scopeManager.containsSymbol(nombreProcedimiento)
            && scopeManager.containsType(nombreProcedimiento))) {
            
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF tablaTipos = scope.getTypeTable();
        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
        //Creo un tipo y un simbolo para el procedimiento y los añado a la tabla
        TypeProcedure tipoProcedimiento = new TypeProcedure(scope, nombreProcedimiento);            
        tablaTipos.addType(nombreProcedimiento, tipoProcedimiento);
        SymbolProcedure simboloProcedimiento = new SymbolProcedure(scope, nombreProcedimiento, tipoProcedimiento);
        tablaSimbolos.addSymbol(nombreProcedimiento, simboloProcedimiento);
            
        // Abro un nuevo ambito para el procedimiento, con una nueva tabla simbolos y tipos
        ScopeIF scopeProcedimiento = scopeManager.openScope(nombreProcedimiento);
        TypeTableIF tablaTiposProcedimiento = scopeProcedimiento.getTypeTable();
        SymbolTableIF tablaSimbolosProcedimiento = scopeProcedimiento.getSymbolTable();
            
        // Almaceno los parametros en la tabla de simbolos y la de tipos
        for (SymbolParameter parametro:listaParametros.getListaParametros()) {
            tablaSimbolosProcedimiento.addSymbol(parametro.getName().toUpperCase(),parametro);
            tipoProcedimiento.addTipoParametro(parametro.getType());
        }
    } else {
        semanticErrorManager.semanticFatalError("ERROR: Procedimiento ya declarada " + nombreProcedimiento
                                                    +" en linea: "+idProcedimiento.getLine());        
    }
        
:}  IS declaraciones:declaraciones cuerpo:cp
{:
    // Comprueba que el identificador que cierra el cuerpo del procedimiento es equivalente al de apertura
    String idCierre = cp.getIdProcedimiento().toUpperCase();
    if (!idProcedimiento.getLexema().equalsIgnoreCase(idCierre)) {
        semanticErrorManager.semanticFatalError("ERROR: el identificador de apertura debe coincidir con el de cierre, apertura: " + idProcedimiento.getLexema()
                                                    +" . Cierre: "+idCierre);       
    }
    
	DeclaracionSubprograma declaracionProcedimiento = new DeclaracionSubprograma(idProcedimiento.getLexema(), declaraciones, cp);
	declaracionProcedimiento.generarCodigoIntermedio();    
    scopeManager.closeScope();
	RESULT = declaracionProcedimiento;
:};
    
parametros_subprograma ::= lista_nombres:listaNombres DOS_PUNTOS tipo:tipo PUNTO_COMA parametros_subprograma:listaParametrosPrevios
{:
    ScopeIF scope = scopeManager.getCurrentScope();
	TypeTableIF tablaTipos = scope.getTypeTable();
	SymbolTableIF tablaSimbolos = scope.getSymbolTable();
    		
	if (!scopeManager.containsType((String)tipo)) {
	   semanticErrorManager.semanticFatalError("ERROR: tipo desconocido " + (String)tipo);
	} else {
        ListaParametrosDeclaracion listaParametros = new ListaParametrosDeclaracion(((ListaParametrosDeclaracion)listaParametrosPrevios).getListaParametros());
        
        // Para cada nombre creo un parametro
		for (Object objeto:((ListaObjetos)listaNombres).getVariables()) {
		       String nombreParametro = (String)objeto;
		       if (scopeManager.containsSymbol(nombreParametro)) {
		           semanticErrorManager.semanticFatalError("ERROR: parametro duplicado " + nombreParametro);
	           } else {
	               SymbolParameter sP = new SymbolParameter(scope, nombreParametro, tablaTipos.getType((String)tipo));
	               tablaSimbolos.addSymbol(nombreParametro, sP);
	               listaParametros.getListaParametros().add(sP);
	           }
	        }
	        RESULT = listaParametros;
	    }	    
:}
    | lista_nombres:listaNombres DOS_PUNTOS tipo:tipo 
{:
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF tablaTipos = scope.getTypeTable();
    SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
    if (!scopeManager.containsType((String)tipo)) {
        semanticErrorManager.semanticFatalError("ERROR: tipo desconocido " + (String)tipo);
    } else {
	   ListaParametrosDeclaracion listaParametros = new ListaParametrosDeclaracion();
        
        // Para cada nombre creo un parametro
	    for (Object objeto:((ListaObjetos)listaNombres).getVariables()) {
            String nombreParametro = (String)objeto;
	        if (scopeManager.containsSymbol(nombreParametro)) {
	           semanticErrorManager.semanticFatalError("ERROR: parametro duplicado " + nombreParametro);
            } else {
                SymbolParameter sP = new SymbolParameter(scope, nombreParametro, scopeManager.searchType((String)tipo));
	            tablaSimbolos.addSymbol(nombreParametro, sP);
	            listaParametros.getListaParametros().add(sP);
            }
        }
	   RESULT = listaParametros;
    }        
:}
    | vacio;
 

cuerpo_funcion::= BEGIN lista_sentencias_funcion:listaSentenciasReturn END IDENTIFICADOR:idFuncion PUNTO_COMA
{:
    CuerpoFuncion cf = new CuerpoFuncion();
	if (listaSentenciasReturn == null) {
        listaSentenciasReturn = new ListaSentenciasReturn();
		semanticErrorManager.semanticInfo("Inicializa listaSentenciasReturn" + listaSentenciasReturn);        
    }
    cf.setListaTiposReturn(listaSentenciasReturn.getListaTiposReturn());
	cf.setListaSentencias(listaSentenciasReturn.getListaSentencias());
    cf.setNombreFuncion(idFuncion.getLexema().toUpperCase());
	
	if (listaSentenciasReturn != null) {
		semanticErrorManager.semanticInfo("listaSentenciasReturn.getIntermediateCode()" + listaSentenciasReturn.getIntermediateCode());
		cf.setIntermediateCode(listaSentenciasReturn.getIntermediateCode());			
    }
        
    RESULT = cf;
:};

lista_sentencias_funcion ::=  sentencia_funcion:posibleReturn PUNTO_COMA lista_sentencias_funcion:listaReturns
{:
    if (listaReturns == null) {
        listaReturns = new ListaSentenciasReturn();
    }
    if (posibleReturn != null && posibleReturn instanceof SentenciaReturn) {
		SentenciaReturn s = (SentenciaReturn)posibleReturn;
        listaReturns.addReturnType(s.getType());
    }
	listaReturns.addSentencia((NonTerminal)posibleReturn);
	listaReturns.generarCodigoIntermedio();
    RESULT = listaReturns;
:} 
    |  vacio
{:
    RESULT = new ListaSentenciasReturn();
:};

sentencia_funcion ::= sentencia:sentencia
{:
	RESULT = sentencia; 
:}
    | sentencia_return:sent_return
{:
    RESULT = sent_return;
:};

sentencia_return ::= RETURN expresion:e
{:
    SentenciaReturn s = new SentenciaReturn(e);
	s.generarCodigoIntermedio();
    RESULT = s;
:};



cuerpo ::=  BEGIN lista_sentencias:listaSentencias END IDENTIFICADOR:idProcedimiento PUNTO_COMA
{:
    Cuerpo cuerpo = new Cuerpo();
    cuerpo.setIdProcedimiento(idProcedimiento.getLexema().toUpperCase());
    if (listaSentencias != null) {
        cuerpo.setIntermediateCode(listaSentencias.getIntermediateCode());			
    }
    RESULT = cuerpo;
:}
    | error 
{: 
    syntaxErrorManager.syntaxDebug ("Error en cuerpo de procedimiento."); 
:};


expresion ::= expresion:exp1 PLUS:operador expresion:exp2
{:
    Expresion e1 = (Expresion)exp1;
    Expresion e2 = (Expresion)exp2;
    TypeIF type1 = e1.getType();
    TypeIF type2 = e2.getType();
        
    if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
        TypeIF tipoExpresion = type1;   // No hay conversion de tipos
        String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
        Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
                                    
        expresionResultado.generarCodigoIntermedio(e1, e2, operador.getLexema());
        RESULT = expresionResultado;
    } else {
        semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
            + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
    }
:}
    | expresion:exp1 MAYOR:operador expresion:exp2
{:
    Expresion e1 = (Expresion)exp1;
    Expresion e2 = (Expresion)exp2;
    TypeIF type1 = e1.getType();
    TypeIF type2 = e2.getType();

    if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
        TypeIF tipoExpresion = scopeManager.searchType(TypeSimple.LOGICO);
        String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();

        Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
        expresionResultado.generarCodigoIntermedio(e1,e2,operador.getLexema());
            
        RESULT = expresionResultado;
    } else {
        semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
             + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
    }
:}            
    | expresion:exp1 IGUAL:operador expresion:exp2
{:
    Expresion e1 = (Expresion)exp1;
    Expresion e2 = (Expresion)exp2;
    TypeIF type1 = e1.getType();
    TypeIF type2 = e2.getType();

    if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
        TypeIF tipoExpresion = scopeManager.searchType(TypeSimple.LOGICO);
        String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
        Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            
        expresionResultado.generarCodigoIntermedio(e1,e2,operador.getLexema());
        semanticErrorManager.semanticDebug("Codigo expresion IGUALDAD: " + expresionResultado.getIntermediateCode());
        RESULT = expresionResultado;
    } else {
        semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
            + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
    }
:}         
    | expresion:exp1 OR:operador expresion:exp2 
{:
    Expresion e1 = (Expresion)exp1;
    Expresion e2 = (Expresion)exp2;
    TypeIF type1 = e1.getType();
    TypeIF type2 = e2.getType();
        
    if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
        TypeIF tipoExpresion = scopeManager.searchType(TypeSimple.LOGICO);
        String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema();
            
        Expresion expresionResultado = new Expresion(tipoExpresion, lexema);            
        expresionResultado.generarCodigoIntermedio(e1,e2,operador.getLexema());
            
        RESULT = expresionResultado;
    } else { 
        semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
            + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
    }
:}            
  
    | ABRE_PARENTESIS:a expresion:exp CIERRA_PARENTESIS:b
{:
    RESULT = exp;
:}        
    
    | llamada_subprograma:l
{:  
    if (l != null && l.getType() != null) {
        // Si existe devolucion es que es una funcion y no un procedimiento
        Expresion expresionResultado = new Expresion(l.getType(), l.getLexema());
        expresionResultado.generarCodigoIntermedio(l);

        RESULT = expresionResultado;
    } else {
       semanticErrorManager.semanticFatalError("ERROR: uso de un procedimiento en una expresion "); 
    }
:}        
    
    | referencia:r
{:   
    TypeIF tipo = r.getType();
    String lexema = r.getLexema().toUpperCase();
    Expresion expresion = new Expresion(tipo, lexema);
    semanticErrorManager.semanticDebug("Creo el objeto expresion " + expresion);
    expresion.generarCodigoIntermedio(r);
    
    semanticErrorManager.semanticDebug("Expresion referencia: " + expresion.getIntermediateCode());
    RESULT = expresion;
:}              
    
    | valor:valor
{:
    Expresion expresion = new Expresion(valor.getType(), valor.getLexema().toUpperCase());
    expresion.generarCodigoIntermedio(valor);
    RESULT = expresion;
:};

referencia ::= IDENTIFICADOR:id 
{:
    String name = id.getLexema().toUpperCase();
    if (scopeManager.containsSymbol(name)) {
        SymbolIF simbolo = scopeManager.searchSymbol(name);
        TypeIF tipo = simbolo.getType();
        Referencia r = new Referencia(tipo, name, id.getLine()); 
        r.generarCodigoIntermedio();
        RESULT = r;
    } else {
       semanticErrorManager.semanticFatalError("ERROR: uso de una referencia desconocida " + id.getLine() + " " + name);         
    }
:}
        | acceso_registro:a
{:
    RESULT = a;
:};

acceso_registro ::= referencia:registro ACCESO IDENTIFICADOR:campo
{:
    String nombreRegistro = registro.getLexema().toUpperCase();
    String nombreCampo = campo.getLexema().toUpperCase();
    TypeIF tipoRegistro = registro.getType();
    if (tipoRegistro instanceof TypeRecord) {
        TypeRecord tRec = (TypeRecord)tipoRegistro;
        if (tRec.containsCampo(nombreCampo)) {
            TypeIF innerType = tRec.getCampo(nombreCampo).getType();
            Referencia r = new Referencia(innerType, nombreRegistro + "." + nombreCampo, campo.getLine());
			r.setAccesoRegistro(true);
			SymbolVariable variableRegistro = (SymbolVariable)scopeManager.searchSymbol(nombreRegistro);
			r.setVariableRegistro(variableRegistro);
			
			SymbolVariable campoRegistro = new SymbolVariable(variableRegistro.getScope(), nombreCampo, innerType);
			r.setCampoRegistro(campoRegistro);
			
            r.generarCodigoIntermedio(registro, nombreCampo);
             
            RESULT = r;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: campo no declarado " + nombreCampo);
        }
    } else {
        semanticErrorManager.semanticFatalError("ERROR: tipo no declarado " + tipoRegistro.getName());
    }
:};

       
lista_sentencias ::=  sentencia:sentencia PUNTO_COMA lista_sentencias:listaSentencias 
    {:
        if (listaSentencias == null) {
            listaSentencias = new ListaSentencias();
        }
        listaSentencias.addSentencia((NonTerminal)sentencia);
        listaSentencias.generarCodigoIntermedio();
        RESULT = listaSentencias;
    :}
        |  vacio {:
        :};

sentencia ::= sentencia_entrada_salida:sentencia
{:
    RESULT = sentencia;
:} 
        | sentencia_if:sentencia
{:
    RESULT = sentencia;
:}
        | sentencia_for:sentencia
{:
    RESULT = sentencia;
:}
        | sentencia_asignacion:sentencia
{:
    RESULT = sentencia;
:}
        | llamada_subprograma:sentencia
{:
    RESULT = sentencia;
:};

sentencia_if ::= IF expresion:objExp THEN lista_sentencias:listaSentencias END IF
{:
    Expresion expCondicion = (Expresion)objExp;
    if (!expCondicion.getType().getName().equalsIgnoreCase(TypeSimple.LOGICO)) {
        semanticErrorManager.semanticFatalError("ERROR: la condicion debe devolver un tipo boolean" );
    }
    SentenciaIF s = new SentenciaIF();
    s.generarCodigoIntermedio(expCondicion, listaSentencias);
    RESULT = s;
:}
        | IF expresion:objExp THEN lista_sentencias:listaSentencias ELSE lista_sentencias:listaSentenciasElse END IF
{:
    Expresion expCondicion = (Expresion)objExp;
    if (!expCondicion.getType().getName().equalsIgnoreCase(TypeSimple.LOGICO)) {
        semanticErrorManager.semanticFatalError("ERROR: la condicion debe devolver un tipo boolean" );
    }
    SentenciaIF s = new SentenciaIF();
    s.generarCodigoIntermedio(expCondicion, listaSentencias, listaSentenciasElse);
    RESULT = s;
:}        
        | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia if"); :};


sentencia_for ::=  FOR IDENTIFICADOR:indice IN expresion:expInicio 
    DELIMITADOR_RANGO expresion:expFin LOOP lista_sentencias:listaSentencias 
    END LOOP
{:
semanticErrorManager.semanticDebug("53");
    //Indice debe corresponder con una variable de tipo entero
    List<SymbolIF> posiblesIndices = scopeManager.searchSymbols(indice.getLexema().toUpperCase());
    if (posiblesIndices == null || posiblesIndices.size() == 0) {
        semanticErrorManager.semanticFatalError("ERROR: simbolo no declarado en indice, linea: " + indice.getLine());
    } else {
        // Compruebo que el tipo de la variable sea entero
        SymbolVariable varIndex = null;
        TypeIF tipoEntero = scopeManager.searchType(TypeSimple.NUMERO);
        for (SymbolIF posibleIndex:posiblesIndices) {
            if (posibleIndex.getType().equals(tipoEntero)) {
                varIndex = (SymbolVariable)posibleIndex;
            }
        }
        if (varIndex == null) {
            semanticErrorManager.semanticFatalError("ERROR: el indice debe ser una variable de tipo entero, linea: " + indice.getLine());
        } else {
            if (!expInicio.getType().equals(tipoEntero) || !expFin.getType().equals(tipoEntero)) {
                semanticErrorManager.semanticFatalError("ERROR: el rango de la sentencia for debe ser expresiones de tipo entero, linea: " + indice.getLine());
            }
        }
        SentenciaFor s = new SentenciaFor();
        s.generarCodigoIntermedio(varIndex, expInicio, expFin, listaSentencias);
        semanticErrorManager.semanticDebug("Codigo FOR: " + s.getIntermediateCode());        
        RESULT = s;
    }
:};      
        
sentencia_asignacion ::= referencia:referencia ASIGNACION expresion:expresion
{:
	semanticErrorManager.semanticDebug("54: sentencia_asignacion ::= referencia:referencia ASIGNACION expresion:expresion");
    
    // Debo comprobar que tanto referencia como expresion coinciden en tipo y que este es uno de los tipos simples
    if (!(referencia.getType() instanceof TypeSimple)) {
        semanticErrorManager.semanticFatalError("ERROR: no se permiten asignaciones a tipos compuestos, linea: " + referencia.getLine());
    } else if (!referencia.getType().equals(expresion.getType())) {
        semanticErrorManager.semanticFatalError("ERROR: tipos distintos en asignacion, linea: " + referencia.getLine()); 
    } else {
        // semanticErrorManager.semanticInfo("Asignacion valida");
        SentenciaAsignacion s = new SentenciaAsignacion();
        s.generarCodigoIntermedio(referencia, expresion);
        semanticErrorManager.semanticDebug("Codigo asignacion: " + s.getIntermediateCode());
        RESULT = s;
    }
:};

sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS expresion:parametro CIERRA_PARENTESIS
{:
	semanticErrorManager.semanticDebug("55: sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS expresion:parametro CIERRA_PARENTESIS");
    if (!(parametro.getType() instanceof TypeSimple)) {
        semanticErrorManager.semanticFatalError("ERROR: parametros no compatibles en put_line " + parametro.getLexema());
    }
    SentenciaPutLine sent = new SentenciaPutLine();
    sent.generarCodigoIntermedio(parametro);
    semanticErrorManager.semanticInfo(sent.getIntermediateCode());
    RESULT = sent;
:}
		| PUT_LINE ABRE_PARENTESIS CADENA:cadena CIERRA_PARENTESIS
{:
	semanticErrorManager.semanticDebug("55b: sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS CADENA:cadena CIERRA_PARENTESIS");
	SentenciaPutLine sent = new SentenciaPutLine();
    sent.generarCodigoIntermedio(cadena.getLexema());
	semanticErrorManager.semanticInfo(sent.getIntermediateCode());
    RESULT = sent;
:};

parametro ::= valor:valor
{:
	semanticErrorManager.semanticDebug("56: parametro ::= valor:valor");
    Parametro parametro =  new Parametro(valor.getType(), valor.getLexema().toUpperCase(), valor.getLine());
    RESULT = parametro;
:}
        | referencia:referencia
{:
semanticErrorManager.semanticDebug("57: referencia:referencia");
    Parametro parametro = new Parametro(referencia.getType(),referencia.getLexema().toUpperCase(),referencia.getLine());
    RESULT = parametro;
:};

llamada_subprograma ::= IDENTIFICADOR:id ABRE_PARENTESIS lista_parametros:pa CIERRA_PARENTESIS
{:
semanticErrorManager.semanticDebug("58: llamada_subprograma ::= IDENTIFICADOR:id ABRE_PARENTESIS lista_parametros:pa CIERRA_PARENTESIS");
    String name = id.getLexema().toUpperCase();
    if (!scopeManager.containsSymbol(name)) {
        semanticErrorManager.semanticFatalError("ERROR: subprograma desconocido " + name + ", linea: " + id.getLine());    
    } else {
        SymbolIF s = scopeManager.searchSymbol(name);
        if (s instanceof SymbolFunction) {
            // Se trata de una funcion
            SymbolFunction sf = (SymbolFunction)s;
            TypeFunction tf = (TypeFunction)sf.getType();
            
            List<TypeIF> paramInvocacion = pa.getParameterTypes();
            List<TypeIF> paramTeoricos = tf.getTipoParametros();
            if (paramInvocacion.equals(paramTeoricos)) {
                //OK
                TypeIF returnType = tf.getTipoResultado();
                
                LlamadaSubprograma funcion = new LlamadaSubprograma(returnType, name);
                funcion.generarCodigoIntermedio(sf, pa);
                RESULT = funcion;
            } else {
                semanticErrorManager.semanticFatalError("ERROR: parametros erroneos en invocacion a funcion " 
                    + name + ", linea: " + id.getLine());    
            }
        } else if (s instanceof SymbolProcedure) {
            // Se trata de un procedimiento
            // Se trata de una funcion
            SymbolProcedure sf = (SymbolProcedure)s;
            TypeProcedure tf = (TypeProcedure)sf.getType();
            
            List<TypeIF> paramInvocacion = pa.getParameterTypes();
            List<TypeIF> paramTeoricos = tf.getTipoParametros();
            if (!paramInvocacion.equals(paramTeoricos)) {
                semanticErrorManager.semanticFatalError("ERROR: parametros erroneos en invocacion a procedimiento " + name + ", linea: " + id.getLine());    
            }
            
            LlamadaSubprograma procedimiento = new LlamadaSubprograma();
            procedimiento.generarCodigoIntermedio(sf, pa);
            RESULT = procedimiento;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: El simbolo " + name 
                + " no se corresponde con un subprograma, linea: " + id.getLine());
        }
    }
:};

lista_parametros ::= expresion:e SEPARADOR_COMA lista_parametros:lista
{:
	semanticErrorManager.semanticDebug("59: lista_parametros ::= expresion:e SEPARADOR_COMA lista_parametros:lista");
    lista.addParameterType(e.getType());
	lista.addParametro(e);
    RESULT = lista;
:}
        | expresion:e
{:
semanticErrorManager.semanticDebug("60: lista_parametros ::= expresion:e");
	ListaParametrosEjecucion lista = new ListaParametrosEjecucion();
	lista.addParameterType(e.getType());
	lista.addParametro(e);
	semanticErrorManager.semanticDebug("59b: Parametros " +  lista.getIntermediateCode());
    RESULT = lista;
:}  
        | vacio
{:
semanticErrorManager.semanticDebug("61: lista_parametros ::= vacio");
    ListaParametrosEjecucion lista = new ListaParametrosEjecucion();
    RESULT = lista;
:};