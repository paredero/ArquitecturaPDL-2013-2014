package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
    
    SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
    SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
    ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
    FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}  

parser code {:
    SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
    
    public void syntax_error(Symbol symbol)
    { 
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxError ("Error sintactico", token);     
    }
        
    public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
    {   
        Token token = (Token) symbol.value;
        syntaxErrorManager.syntaxFatalError ("Error fatal", token);
    }
:}

// Declaración de terminales (Ejemplo)

// Palabras reservadas
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FOR;
terminal Token FUNCTION;
terminal Token IF;
terminal Token IN;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OR;
terminal Token PROCEDURE;
terminal Token PUT_LINE;
terminal Token RECORD;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;

// OPERADORES
terminal Token PLUS;
terminal Token MAYOR;
terminal Token IGUAL;
terminal Token ASIGNACION;
terminal Token ACCESO;

// DELIMITADORES
terminal Token ABRE_PARENTESIS;
terminal Token CIERRA_PARENTESIS;
terminal Token DELIMITADOR_RANGO;
terminal Token SEPARADOR_COMA;
terminal Token PUNTO_COMA;
terminal Token DOS_PUNTOS;

// OTROS
terminal Token NUMERO;
terminal Token IDENTIFICADOR;
terminal Token CADENA;

// Declaración de no terminales
// no modificar los propuestos

non terminal            program;
non terminal Axiom      axiom;

non terminal    vacio;
non terminal    cabecera;
non terminal    declaraciones;
non terminal    declaracion_constantes;
non terminal    declaracion_registros;
non terminal    declaracion_variables;
non terminal    declaracion_subprogramas;
non terminal    lista_nombres;
non terminal    constante;
non terminal    valor;

non terminal    registro;
non terminal    ListaObjetos lista_campos;
non terminal    tipo;

non terminal    variable;
non terminal    cuerpo;
non terminal    lista_sentencias;
non terminal    sentencia;
non terminal    sentencia_entrada_salida;
non terminal    sentencia_asignacion;
non terminal    sentencia_if;
non terminal    sentencia_for;
non terminal    referencia;
non terminal    acceso_registro;
non terminal    expresion;
non terminal    parametro;
non terminal    llamada_subprograma;
non terminal    ListaParametros lista_parametros;
non terminal    subprograma;
non terminal    funcion;
non terminal    procedimiento;
non terminal    parametros_subprograma;
non terminal    tipo_primitivo;
non terminal    cuerpo_funcion;
non terminal    lista_sentencias_funcion;
non terminal    sentencia_funcion;
non terminal    sentencia_return;

// Declaración de relaciones de precedencia, SEPARADOS POR COMAS

precedence left OR;
precedence left IGUAL;
precedence left MAYOR;
precedence left PLUS;
precedence left ACCESO, ABRE_PARENTESIS, CIERRA_PARENTESIS;

// Declaración de reglas de producción


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
        // No modificar esta estructura, aunque se pueden añadir más acciones semánticas
        
        List intermediateCode = ax.getIntermediateCode ();
        finalCodeFactory.create (intermediateCode);
                
        syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};


axiom ::= cabecera declaraciones cuerpo
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de procedimiento principal."); :};

vacio ::= ;

cabecera ::= PROCEDURE IDENTIFICADOR:id ABRE_PARENTESIS CIERRA_PARENTESIS IS
    {:
        //Crear el ámbito global del programa asociado al nombre del procedimiento.
        String name = id.getLexema();
        scopeManager.openScope(name);
        ScopeIF scope = scopeManager.getCurrentScope();
        semanticErrorManager.semanticDebug("Abierto ambito " + name);
        
        //******************* Ahora insertar tipos basicos en la tabla
        TypeTableIF tablaTipos = scope.getTypeTable();
        TypeSimple tipoBooleano = new TypeSimple(scope);
        tipoBooleano.setName("BOOLEAN");
        tablaTipos.addType(tipoBooleano);
        TypeSimple tipoEntero = new TypeSimple(scope);
        tipoEntero.setName("INTEGER");
        tablaTipos.addType(tipoEntero);
        TypeSimple tipoString = new TypeSimple(scope);
        tipoString.setName("STRING");
        tablaTipos.addType(tipoString);        
    :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en declaracion de cabecera."); :};

tipo ::= IDENTIFICADOR:id  {: RESULT=id.getLexema();:}
        | INTEGER:t {: RESULT="INTEGER"; :} 
        | BOOLEAN:t {: RESULT="BOOLEAN"; :};

tipo_primitivo ::= INTEGER:t {: RESULT="INTEGER"; :} 
        | BOOLEAN:t {: RESULT="BOOLEAN"; :};
        
valor ::= NUMERO {: RESULT="INTEGER"; :}
        | TRUE {: RESULT="BOOLEAN"; :}
        | FALSE {: RESULT="BOOLEAN"; :}
        | CADENA {:RESULT="STRING":};             

declaraciones ::= declaracion_constantes;

declaracion_constantes ::= constante declaracion_constantes 
        | declaracion_registros;

/*******************************************************************************
CAMBIAR LA CONSTANTE EN TRES PRODUCCIONES SEGUN EL TIPO DE VALOR
1 Divido valor en valor_numerico y valor_booleano
2 Divido la produccion constante en constante:: ...valor_numeroco | ...valor_booleano
*******************************************************************************/
constante ::= lista_nombres:listaNombres DOS_PUNTOS CONSTANT ASIGNACION valor:v PUNTO_COMA
    {:
        ScopeIF scope = scopeManager.getCurrentScope();
        String nombreConstante = (String)((ListaObjetos)listaNombres).get(0);
        semanticErrorManager.semanticInfo("Declaracion de constante " + nombreConstante);
        // comprueba si la constante ha sido declarada y se encuentra en la tabla de simbolos
        if (scope.getSymbolTable().containsSymbol(nombreConstante)) {
            semanticErrorManager.semanticFatalError("Error: la constante "+nombreConstante+" ya ha sido declarada");
        } else {
            // Creo la constante en el ambito
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            String tipo = (String)v;
            SymbolConstant simboloCte = new SymbolConstant(scope,nombreConstante,scopeManager.searchType(tipo));
            // La guardo en la tabla de simbolos
            tablaSimbolos.addSymbol(nombreConstante, simboloCte);
            semanticErrorManager.semanticInfo("Constante " + nombreConstante + " " + tipo + " guardada en la tabla de simbolos");
        }
    :};
    
lista_nombres ::= IDENTIFICADOR:id SEPARADOR_COMA lista_nombres:listaNombres
    {:
        semanticErrorManager.semanticInfo("Se encuentra el nombre " + id.getLexema()); 
        semanticErrorManager.semanticInfo("Se encuentra el listado " + listaNombres.toString());
        ListaObjetos listaResultado = new ListaObjetos((ListaObjetos)listaNombres);
        listaResultado.add(id.getLexema());
        RESULT = listaResultado;
    :}
    | IDENTIFICADOR:id
    {:
        ListaObjetos listaNombres = new ListaObjetos();
        listaNombres.add(id.getLexema());
        RESULT = listaNombres;
    :};

declaracion_registros ::= registro declaracion_registros 
        | declaracion_variables;
        
registro ::= TYPE IDENTIFICADOR:idRegistro IS RECORD lista_campos:listaCamposRegistro END RECORD PUNTO_COMA
    {:
        syntaxErrorManager.syntaxInfo("Declaracion de registro " + idRegistro.getLexema() + ". Linea " + idRegistro.getLine());
        // Comprueba en la tabla de tipos si el tipo ya está declarado
        ScopeIF scope = scopeManager.getCurrentScope();
        
        TypeTableIF typeTable = scope.getTypeTable();
        
        if (typeTable.containsType(idRegistro.getLexema())) {
            semanticErrorManager.semanticFatalError("Error: el tipo "+idRegistro.getLexema()+" en la linea: "+idRegistro.getLine()+" ya ha sido declarado");
        } else {
            TypeRecord tipoRegistro = new TypeRecord(scope, idRegistro.getLexema());
            typeTable.addType(tipoRegistro);
            syntaxErrorManager.syntaxInfo("Tipo registro " + idRegistro.getLexema() + ". Añadido en la tabla de tipos");
            // Compruebo los campos
        for (int i = 0; i<listaCamposRegistro.size();i++) {
            CampoRegistro c = (CampoRegistro) listaCamposRegistro.get(i);
            SymbolVariable var = (SymbolVariable) c.getSymbol();
            if (!tipoRegistro.containsCampo(c.getNombre())) {
                semanticErrorManager.semanticInfo("Se inserta el campo " + c.getNombre() + "linea " + c.getLinea() + "... ");
                tipoRegistro.addCampo(c.getNombre(), var); 
                semanticErrorManager.semanticInfo("...OK!");                                        
            } else {
                semanticErrorManager.semanticFatalError ("El campo: " + c.getNombre() +" en " + c.getLinea() + " ya ha sido definido.");
            }
        } 
        }
        
        
    :};

/**
    CAMBIO: Elimino el no terminal campo y lo sustituyo por su produccion
**/
lista_campos ::= IDENTIFICADOR:idCampo DOS_PUNTOS tipo:tipoCampo PUNTO_COMA lista_campos:listaCampos
    {:
    // Añadir ID + tipo a lista de campos del registro registro
    ScopeIF scope = scopeManager.getCurrentScope();
    TypeTableIF tablaTipos = scope.getTypeTable();
    SymbolIF simbolo = new SymbolVariable(scope,
                                            idCampo.getLexema(),
                                            scopeManager.searchType(tipoCampo.toString()));
    CampoRegistro campo = new CampoRegistro(idCampo.getLexema(), idCampo.getLine(), 
                                            idCampo.getColumn(), simbolo);
    semanticErrorManager.semanticInfo("Identificado el campo " + campo.getNombre() + ". ");
    if (listaCampos == null) {
        listaCampos = new ListaObjetos();
    }
    listaCampos.add(campo);
    
    RESULT = listaCampos;
    :} 
    | vacio;
   

declaracion_variables ::= variable declaracion_variables 
        | declaracion_subprogramas {:syntaxErrorManager.syntaxDebug("Declaracion subprogramas");:};
/**
    CAMBIO: sustituyo lista_nombres por su produccion
**/
variable ::= lista_nombres:objListaNombres DOS_PUNTOS tipo:objTipo PUNTO_COMA
    {:
        String tipoVariable = (String)objTipo;
        ListaObjetos listaNombres = (ListaObjetos)objListaNombres; 
        semanticErrorManager.semanticDebug("Declaracion variables de tipo " + tipoVariable);
        
        ScopeIF scope = scopeManager.getCurrentScope();
        TypeTableIF tablaTipos = scope.getTypeTable();
        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
        
        // Si el tipo no existe, error
        if (!tablaTipos.containsType(tipoVariable)) {
            semanticErrorManager.semanticFatalError("ERROR: El tipo " 
                                + tipoVariable + 
                                " no ha sido definido en el programa");
        } else {
            semanticErrorManager.semanticDebug("Encontrado el tipo, valida que no haya nombres duplicados");
	        // Para cada nombre creo una variable
	        for (Object objeto:listaNombres.getVariables()) {
	           String nombreVar = (String)objeto;
	            semanticErrorManager.semanticInfo("Declaracion de variable " + nombreVar);
	            if (tablaSimbolos.containsSymbol(nombreVar)) {
	               semanticErrorManager.semanticFatalError("ERROR: variable duplicada " + nombreVar);
	            } else {
	               semanticErrorManager.semanticDebug("Variable valida, crea el simbolo");
	               SymbolVariable sV = new SymbolVariable(scope, nombreVar, tablaTipos.getType(tipoVariable));
	               tablaSimbolos.addSymbol(nombreVar, sV);
	            }
	        }
        }
        semanticErrorManager.semanticDebug("End declaracion variable");
    :};


declaracion_subprogramas ::= subprograma declaracion_subprogramas 
        | vacio;
        
subprograma ::= funcion
    | procedimiento; 

funcion ::= FUNCTION IDENTIFICADOR:idFuncion ABRE_PARENTESIS parametros_subprograma:listaParametros CIERRA_PARENTESIS RETURN tipo_primitivo:tipoRetorno
    {:
        String nombreFuncion = idFuncion.getLexema();
        
        // Comprueba si la funcion ha sido declarada
        if (!(scopeManager.containsSymbol(nombreFuncion)
            && scopeManager.containsType(nombreFuncion))) {
            semanticErrorManager.semanticInfo("Declaracion de funcion " + nombreFuncion 
                                            + " en linea " + idFuncion.getLine());
            
            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
            //Creo un tipo y un simbolo para la funcion y los añado a la tabla
            TypeFunction tipoFuncion = new TypeFunction(scope, nombreFuncion);
            TypeIF tipoResultado = scopeManager.searchType((String)tipoRetorno);
            semanticErrorManager.semanticInfo("Retorna " + tipoResultado.getName());
            tipoFuncion.setTipoResultado(tipoResultado);
            tablaTipos.addType(nombreFuncion, tipoFuncion);
            SymbolFunction simboloFuncion = new SymbolFunction(scope, nombreFuncion, tipoFuncion);
            tablaSimbolos.addSymbol(nombreFuncion, simboloFuncion);
            
            // Abro un nuevo ambito para la funcion, con una nueva tabla simbolos y tipos
            semanticErrorManager.semanticInfo("Nuevo ambito " + nombreFuncion);
            ScopeIF scopeFuncion = scopeManager.openScope(nombreFuncion);
            TypeTableIF tablaTiposFuncion = scopeFuncion.getTypeTable();
            SymbolTableIF tablaSimbolosFuncion = scopeFuncion.getSymbolTable();
            

            for (SymbolParameter parametro:((ListaParametros)listaParametros).getListaParametros()) {
                semanticErrorManager.semanticInfo("Declaracion de parametro " + parametro.getName() 
                                + " de tipo " + parametro.getType().getName());
                tablaSimbolosFuncion.addSymbol(parametro.getName(),parametro);
                tipoFuncion.addTipoParametro(parametro.getType());
            }
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Funcion ya declarada " + nombreFuncion
                                                    +" en linea: "+idFuncion.getLine());        }
        
    :} IS declaraciones cuerpo_funcion;

parametros_subprograma ::= lista_nombres:listaNombres DOS_PUNTOS tipo:tipo PUNTO_COMA parametros_subprograma:listaParametrosPrevios
	    {:
		ScopeIF scope = scopeManager.getCurrentScope();
		TypeTableIF tablaTipos = scope.getTypeTable();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
		
		if (!scopeManager.containsType((String)tipo)) {
		   semanticErrorManager.semanticFatalError("ERROR: tipo desconocido " + (String)tipo);
		} else {
		   ListaParametros listaParametros = new ListaParametros(((ListaParametros)listaParametrosPrevios).getListaParametros());
		   // Para cada nombre creo un parametro
		   for (Object objeto:((ListaObjetos)listaNombres).getVariables()) {
		       String nombreParametro = (String)objeto;
		       semanticErrorManager.semanticInfo("Declaracion de parametro " + nombreParametro + " tipo " + (String)tipo);
		       if (scopeManager.containsSymbol(nombreParametro)) {
		           semanticErrorManager.semanticFatalError("ERROR: parametro duplicado " + nombreParametro);
	           } else {
	               semanticErrorManager.semanticDebug("Parametro valida, crea el simbolo");
	               SymbolParameter sP = new SymbolParameter(scope, nombreParametro, tablaTipos.getType((String)tipo));
	               tablaSimbolos.addSymbol(nombreParametro, sP);
	               listaParametros.getListaParametros().add(sP);
	           }
	        }
	        RESULT = listaParametros;
	    }	    
	    :}
        | lista_nombres:listaNombres DOS_PUNTOS tipo:tipo 
        {:
            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
            if (!scopeManager.containsType((String)tipo)) {
                semanticErrorManager.semanticFatalError("ERROR: tipo desconocido " + (String)tipo);
            } else {
	            ListaParametros listaParametros = new ListaParametros();
	            // Para cada nombre creo un parametro
	            for (Object objeto:((ListaObjetos)listaNombres).getVariables()) {
	               String nombreParametro = (String)objeto;
	                semanticErrorManager.semanticInfo("Declaracion de parametro " + nombreParametro);
	                if (scopeManager.containsSymbol(nombreParametro)) {
	                   semanticErrorManager.semanticFatalError("ERROR: parametro duplicado " + nombreParametro);
	                } else {
	                   semanticErrorManager.semanticDebug("Parametro valida, crea el simbolo");
	                   SymbolParameter sP = new SymbolParameter(scope, nombreParametro, tablaTipos.getType((String)tipo));
	                   tablaSimbolos.addSymbol(nombreParametro, sP);
	                   listaParametros.getListaParametros().add(sP);
	                }
	            }
	            RESULT = listaParametros;
            }        
        :}
        | vacio;
        
procedimiento ::= PROCEDURE IDENTIFICADOR:idProcedimiento ABRE_PARENTESIS parametros_subprograma:listaParametros CIERRA_PARENTESIS
    {:
        // El procedimiento es igual que la funcion, pero crea un tipo procedure que no tiene retorno
        String nombreProcedimiento = idProcedimiento.getLexema();
        
        // Comprueba si la funcion ha sido declarada
        if (!(scopeManager.containsSymbol(nombreProcedimiento)
            && scopeManager.containsType(nombreProcedimiento))) {
            semanticErrorManager.semanticInfo("Declaracion de procedimiento " + nombreProcedimiento 
                                            + " en linea " + idProcedimiento.getLine());
            
            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            
            //Creo un tipo y un simbolo para el procedimiento y los añado a la tabla
            TypeProcedure tipoProcedimiento = new TypeProcedure(scope, nombreProcedimiento);
            
            tablaTipos.addType(nombreProcedimiento, tipoProcedimiento);
            SymbolProcedure simboloProcedimiento = new SymbolProcedure(scope, nombreProcedimiento, tipoProcedimiento);
            tablaSimbolos.addSymbol(nombreProcedimiento, simboloProcedimiento);
            
            // Abro un nuevo ambito para el procedimiento, con una nueva tabla simbolos y tipos
            semanticErrorManager.semanticInfo("Nuevo ambito " + nombreProcedimiento);
            ScopeIF scopeProcedimiento = scopeManager.openScope(nombreProcedimiento);
            TypeTableIF tablaTiposProcedimiento = scopeFuncion.getTypeTable();
            SymbolTableIF tablaSimbolosProcedimiento = scopeFuncion.getSymbolProcedimiento();
            
            // Almaceno los parametros en la tabla de simbolos y la de tipos
            for (SymbolParameter parametro:((ListaParametros)listaParametros).getListaParametros()) {
                semanticErrorManager.semanticInfo("Declaracion de parametro " + parametro.getName() 
                                + " de tipo " + parametro.getType().getName());
                tablaSimbolosProcedimiento.addSymbol(parametro.getName(),parametro);
                tipoProcedimiento.addTipoParametro(parametro.getType());
            }
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Funcion ya declarada " + nombreFuncion
                                                    +" en linea: "+idFuncion.getLine());        }
        
    :}  IS declaraciones cuerpo;

cuerpo_funcion::= BEGIN lista_sentencias_funcion END IDENTIFICADOR PUNTO_COMA;

lista_sentencias_funcion ::=  sentencia_funcion PUNTO_COMA lista_sentencias_funcion |  vacio;

sentencia_funcion ::= sentencia | sentencia_return;

sentencia_return ::= RETURN expresion;



cuerpo ::=  BEGIN lista_sentencias END IDENTIFICADOR PUNTO_COMA
    {:
        semanticErrorManager.semanticDebug("Cierro ambito ");
        scopeManager.closeScope();
    :}
        | error {: syntaxErrorManager.syntaxDebug ("Error en cuerpo de procedimiento."); :};
        
lista_sentencias ::=  sentencia PUNTO_COMA lista_sentencias 
        |  vacio;

sentencia ::= sentencia_entrada_salida 
        | sentencia_if
        | sentencia_for
        | sentencia_asignacion
        | llamada_subprograma;

sentencia_if ::= IF expresion THEN lista_sentencias END IF
        | IF expresion THEN lista_sentencias ELSE lista_sentencias END IF
        | error {: syntaxErrorManager.syntaxDebug ("Error en sentencia if"); :};


sentencia_for ::=  FOR expresion IN expresion DELIMITADOR_RANGO expresion LOOP lista_sentencias END LOOP;      
        
sentencia_asignacion ::= referencia ASIGNACION expresion;


        
/*******************************************************************************
    CAMBIO: TRUE,FALSE pasan a valor_booleano
    NUMERO pasa a valor_numerico
*******************************************************************************/
expresion ::= expresion:exp1 PLUS:operador expresion:exp2
    {:
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        semanticErrorManager.semanticDebug("Expresion " + type1.getName() + " + " + type2.getType());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = type1;   // No hay conversion de tipos
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema():
            semanticErrorManager.semanticDebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}
        | expresion:exp1 MAYOR:operador expresion:exp2
    {:
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        semanticErrorManager.semanticDebug("Expresion " + type1.getName() + " > " + type2.getType());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = expresion.cast(operador);   // Aqui si hay conversion de tipos
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema():
            semanticErrorManager.semanticDebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}            
        | expresion:exp1 IGUAL:operador expresion:exp2
    {:
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        semanticErrorManager.semanticDebug("Expresion " + type1.getName() + " == " + type2.getType());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = expresion.cast(operador);   // Aqui si hay conversion de tipos
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema():
            semanticErrorManager.semanticDebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}         
        | expresion:exp1 OR:operador expresion:exp2 
    {:
        Expresion e1 = (Expresion)exp1;
        Expresion e2 = (Expresion)exp2;
        TypeIF type1 = e1.getType();
        TypeIF type2 = e2.getType();
        semanticErrorManager.semanticDebug("Expresion " + type1.getName() + " OR " + type2.getType());
        if (Expresion.tiposCompatibles(operador.getLexema(),type1,type2)) {
            //OK
            TypeIF tipoExpresion = expresion.cast(operador);
            String lexema = e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema():
            semanticErrorManager.semanticDebug("Expresion " + lexema);
            Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
            RESULT = expresionResultado;
        } else {
            semanticErrorManager.semanticFatalError("ERROR: Tipos incompatibles en expresion " 
                          + e1.getLexema() + " " + operador.getLexema() + " " + e2.getLexema()); 
        }
    :}            
        | ABRE_PARENTESIS:a expresion:exp CIERRA_PARENTESIS:b
{:
    Expresion e = (Expresion)exp;
    TypeIF tipoExpresion = e.getType();
    String lexema = a.getLexema() + " " + e.getLexema() + " " + b.getLexema():
    semanticErrorManager.semanticDebug("Expresion " + lexema);
    Expresion expresionResultado = new Expresion(tipoExpresion, lexema);
    RESULT = expresionResultado;
:}        
        | llamada_subprograma:objLlamada
{:  
    Llamada l = (Llamada)objLlamada;
    if (l.getType() instanceOf TypeFunction) {
        Expresion expresionResultado = new Expresion(l.getType().getTipoResultado(), l.getLexema());
        RESULT expresionResultado;
    } else {
       semanticErrorManager.semanticFatalError("ERROR: uso de un procedimiento en una expresion " + l.getLine() + " " + l.getLexema()); 
    }
:}        
        | referencia:ref
{:
    Referencia r = (Referencia)ref;
    TypeIF tipo = r.getType();
    String lexema = r.getLexema();
    RESULT = new Expresion(tipo, lexema);
:}              
        | valor:valor
{:
    TypeIF tipo = scopeManager.searchType((String)valor);
    Expresion expresionResultado = new Expresion(tipo, (String)valor);
    RESULT = expresionResultado;
:};

referencia ::= IDENTIFICADOR:id 
{:
    String name = id.getLexema();
    if (scopeManager.contains(name)) {
        SymbolIF simbolo = scopeManager.searchSymbol(name);
        TypeIF tipo = simbolo.getType();
        Referencia r = new Referencia(tipo, name); 
        RESULT = r;
    } else {
       semanticErrorManager.semanticFatalError("ERROR: uso de una referencia desconocida " + id.getLine() + " " + name);         
    }
:}
        | acceso_registro:a
{:
    RESULT = (Referencia)a;
:};

acceso_registro ::= referencia:objRegistro ACCESO identificador:campo
{:
    Referencia registro = (Referencia)objRegistro;
    String nombreRegistro = registro.getNombre();
    String nombreCampo = campo.getLexema();
    TypeIf tipoRegistro = registro.getType();
    if (tipoRegistro instanceof TypeRecord) {
        TypeRecord tRec = (TypeRecord)tipoRegistro;
        if (tRec.containsCampo(nombreCampo)) {
            TypeIF innerType = tRec.getCampo(nombreCampo);
            RESULT = new Referencia(innerType, nombreRegistro + "." + nombreCampo);
        } else {
            semanticErrorManager.semanticFatalError("ERROR: campo no declarado " + nombreCampo);
        }
    } else {
        semanticErrorManager.semanticFatalError("ERROR: tipo no declarado " + tipoRegistro.getName());
    }
:};

sentencia_entrada_salida ::= PUT_LINE ABRE_PARENTESIS parametro CIERRA_PARENTESIS;

parametro ::= CADENA:c 
        | NUMERO:n
        | referencia:r;

llamada_subprograma ::= IDENTIFICADOR ABRE_PARENTESIS lista_parametros CIERRA_PARENTESIS;

lista_parametros ::= expresion SEPARADOR_COMA lista_parametros
        | expresion
        | vacio;